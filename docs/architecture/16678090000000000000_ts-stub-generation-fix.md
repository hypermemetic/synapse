# TypeScript Stub Generation: Missing Types and Syntax Errors

## Problem Statement

The hub-codegen TypeScript generator produces invalid syntax when creating stubs for missing types:

```typescript
// ❌ Invalid TypeScript - dots not allowed in type names
export type Arbor.UUID = unknown;
export type Claudecode.Position = unknown;
export type Forge.Forge = unknown;
```

This causes TypeScript compilation to fail with:
```
types.ts(2428,18): error TS1005: '=' expected.
```

## Root Cause Analysis

### 1. How Missing Types Are Detected

**Location**: `hub-codegen/src/generator/types.rs` (lines 85-169)

The generator walks the IR twice:

```rust
// Step 1: Collect all type references
let referenced_types = collect_all_referenced_types(ir);

// Step 2: Identify which are actually defined
let defined_types: HashSet<&String> = ir.ir_types.keys().collect();

// Step 3: Compute missing = referenced - defined
let missing_types: HashSet<&String> = referenced_types
    .difference(&defined_types)
    .filter(|name| !is_core_transport_type(name))
    .copied()
    .collect();
```

Types are considered "missing" when:
- A method or type references them via `RefNamed("arbor.UUID")`
- But they don't exist as keys in `ir.ir_types`

### 2. Why Types Go Missing

From Synapse's IR builder (`src/Synapse/IR/Builder.hs`):

**Type references are qualified**:
```haskell
-- Line 485: When encountering a $ref, create qualified RefNamed
namespace <> "." <> extractRefName ref
```

**Type definitions are also qualified**:
```haskell
-- Line 414: Store types with qualified keys
Map.fromList [(namespace <> "." <> typeName, typedef)]
```

**The gap occurs when**:
- Method A in namespace `cone` references type `arbor.UUID`
- The `arbor` plugin's schema wasn't fully walked or didn't include `UUID` in its `$defs`
- Result: reference exists, definition doesn't

This is legitimate - it represents **cross-namespace type references where the source type isn't available**.

### 3. The Bug: Namespace Dots in Type Names

**Location**: `hub-codegen/src/generator/types.rs` line 203

```rust
lines.push(format!("export type {} = unknown;", to_pascal(&name)));
```

The `to_pascal()` function (lines 505-519) only treats `_` and `-` as word boundaries:

```rust
fn to_pascal(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize = true;
    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize = true;
        } else if capitalize {
            result.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(c);  // <-- Dots pass through unchanged!
        }
    }
    result
}
```

**Result**:
- `"arbor.UUID"` → `"Arbor.UUID"` (invalid TypeScript)
- `"claudecode.Position"` → `"Claudecode.Position"` (invalid TypeScript)

## Solution Options

### Option A: Strip Namespace Prefix (Quick Fix)

Use only the local name when generating stubs:

```rust
// In types.rs line 201-204
for name in sorted_missing {
    lines.push(format!("/** Stub type - definition missing from IR */"));
    let local_name = split_qualified_name(&name).1;  // Extract local part
    lines.push(format!("export type {} = unknown;", to_pascal(local_name)));
    lines.push("".to_string());
}
```

**Result**:
```typescript
/** Stub type - definition missing from IR */
export type UUID = unknown;

/** Stub type - definition missing from IR */
export type Position = unknown;
```

**Pros**:
- Simple, one-line fix
- Valid TypeScript
- Types are usable immediately

**Cons**:
- Loses namespace context
- Potential name collisions if multiple namespaces have missing types with same local name
- Stubs are in global scope, not namespace-specific

---

### Option B: Flatten Namespace into Type Name (Medium Fix)

Make `to_pascal()` treat dots as word boundaries:

```rust
fn to_pascal(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize = true;
    for c in s.chars() {
        if c == '_' || c == '-' || c == '.' {  // <-- Handle dots
            capitalize = true;
        } else if capitalize {
            result.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            result.push(c);
        }
    }
    result
}
```

**Result**:
```typescript
/** Stub type - definition missing from IR */
export type ArborUUID = unknown;

/** Stub type - definition missing from IR */
export type ClaudecodePosition = unknown;
```

**Pros**:
- Preserves namespace information in the type name
- No name collisions
- Valid TypeScript

**Cons**:
- Generated names don't match the original type names
- If the real type is later added to IR, name mismatch could cause confusion

---

### Option C: Namespace-Scoped Stubs (Best Long-Term)

Generate stubs in the appropriate namespace folder:

```rust
// In generate_namespace_types() or similar
// When collecting types for a namespace, also check for missing types
// that are referenced FROM this namespace

pub fn generate_types_for_namespace(ir: &IR, namespace: &str) -> String {
    // ... existing type generation ...

    // Add stubs for missing types referenced by this namespace's methods
    let missing_for_namespace = collect_missing_types_for_namespace(ir, namespace);

    for local_name in missing_for_namespace {
        lines.push(format!("/** Stub type - definition missing from IR */"));
        lines.push(format!("export type {} = unknown;", to_pascal(local_name)));
    }
}
```

**Result**:
```typescript
// arbor/types.ts
export type UUID = unknown;  // Missing type, scoped to arbor namespace

// claudecode/types.ts
export type Position = unknown;  // Missing type, scoped to claudecode namespace
```

**Pros**:
- Stubs are properly scoped
- Matches the namespace module structure
- No global namespace pollution
- Clear which namespace "owns" each stub

**Cons**:
- More complex implementation
- Requires refactoring stub generation logic
- May need to update import collection

---

### Option D: Skip Stub Generation (Alternative)

Don't generate stubs at all - let TypeScript fail at compile time:

```rust
// Simply remove stub generation code (lines 187-206)
```

**Pros**:
- Clearer signal that types are genuinely missing
- Forces fixing the root cause (incomplete schemas)

**Cons**:
- Generated code won't type-check
- Makes it harder to use the client incrementally

## Recommended Solution

**Immediate**: Implement **Option A** (strip namespace prefix)
- One-line fix, unblocks TypeScript compilation
- Good enough for current use case

**Long-term**: Implement **Option C** (namespace-scoped stubs)
- Proper architecture that scales
- Aligns with per-namespace module structure
- Best user experience

## Implementation Plan

### Phase 1: Quick Fix (Option A)

```diff
--- a/hub-codegen/src/generator/types.rs
+++ b/hub-codegen/src/generator/types.rs
@@ -200,7 +200,8 @@

         for name in sorted_missing {
             lines.push(format!("/** Stub type - definition missing from IR */"));
-            lines.push(format!("export type {} = unknown;", to_pascal(&name)));
+            let (_ns, local) = split_qualified_name(name);
+            lines.push(format!("export type {} = unknown;", to_pascal(local)));
             lines.push("".to_string());
         }
     }
```

### Phase 2: Proper Solution (Option C)

1. Add `collect_missing_types_for_namespace(ir: &IR, namespace: &str) -> Vec<String>`
2. Integrate into `generate_types_for_namespace()`
3. Remove global stub generation from `generate_core_types()`
4. Update tests to verify namespace-scoped stubs

## Testing Strategy

### Manual Verification
```bash
# Generate TypeScript
cabal run synapse -- --emit-ir plexus > /tmp/ir.json
cd hub-codegen && cargo run -- /tmp/ir.json -o /tmp/generated

# Type check
cd /tmp/generated
npm install
npm run typecheck  # Should pass with no errors
```

### Automated Tests

Add test in `hub-codegen/tests/`:

```rust
#[test]
fn test_missing_types_generate_valid_typescript() {
    let ir = load_test_ir();
    let output = generate_types(&ir);

    // Should not contain invalid syntax like "Arbor.UUID"
    assert!(!output.contains("export type ") && output.contains("."));

    // All type exports should be valid identifiers
    for line in output.lines() {
        if line.starts_with("export type ") {
            let type_name = extract_type_name(line);
            assert!(is_valid_ts_identifier(type_name));
        }
    }
}
```

## Related Issues

This fix also sets the foundation for:
1. **Better schema validation**: Detect missing types at IR build time
2. **Cross-namespace type imports**: Automatically import types from other namespace modules
3. **Type provenance tracking**: Know which namespace "owns" each type

## References

- TypeScript identifier spec: https://tc39.es/ecma262/#prod-IdentifierName
- Hub-codegen generator: `hub-codegen/src/generator/types.rs`
- Synapse IR builder: `synapse/src/Synapse/IR/Builder.hs`
