# Multi-Backend Architecture Design

## Current State

Synapse currently connects to a single backend (Plexus) on `localhost:4444`. The CLI structure is:

```
synapse [FLAGS] [PATH...]
```

Where:
- `synapse` — shows help + root schema from connected backend
- `synapse cone list` — navigates to `cone.list` method
- `synapse plexus cone list` — same as above (root namespace stripped)

### Path Normalization

The `Navigate` module (`src/Synapse/Algebra/Navigate.hs`) normalizes paths by stripping the root namespace if it matches the first path segment:

```haskell
navigate target = do
  root <- fetchSchemaAt []
  let normalizedTarget = case target of
        (seg:rest) | seg == psNamespace root -> rest
        _ -> target
  withFreshVisited $ navigateFrom root [] normalizedTarget
```

This allows both `synapse cone list` and `synapse plexus cone list` to work equivalently.

## Future: Multi-Backend Support

The vision is for Synapse to support multiple backends:

```
synapse [FLAGS] <backend> [PATH...]
```

Examples:
- `synapse plexus cone list` — connect to plexus, call `cone.list`
- `synapse agenthub tasks run` — connect to agenthub, call `tasks.run`
- `synapse toolhub search` — connect to toolhub, call `search`

### Backend Discovery

The first positional argument would be the backend name. Synapse would:

1. Connect to the configured host:port (default `localhost:4444`)
2. Call `<backend>.schema` to fetch the root schema
3. Navigate the remaining path within that backend

### Required Protocol Change: Raw Schema Endpoint

Currently, fetching the root schema requires knowing the backend name in advance to call `plexus.schema`. This creates a chicken-and-egg problem for true multi-backend support.

**Proposed Substrate Enhancement:**

Add a bare `schema` method at the RPC level (no namespace prefix) that returns the root schema:

```json
// Current (requires knowing "plexus")
{"jsonrpc":"2.0","id":1,"method":"plexus.schema","params":{}}

// Future (generic entry point)
{"jsonrpc":"2.0","id":1,"method":"schema","params":{}}
```

This would allow Synapse to:
1. Connect to any backend
2. Call bare `schema` to discover what's there
3. Use the returned `namespace` field to understand the backend identity

### Alternative: Backend Registry

Another approach is a backend registry/discovery mechanism:

```json
{"jsonrpc":"2.0","id":1,"method":"backends","params":{}}
// Returns: ["plexus", "agenthub", "toolhub"]
```

This would let Synapse enumerate available backends before connecting.

## Implementation Phases

### Phase 1 (Current)
- Single backend (plexus) on hardcoded port
- Path normalization strips root namespace
- `synapse plexus ...` and `synapse ...` work equivalently

### Phase 2
- First arg parsed as backend name
- Transport layer calls `<backend>.schema` dynamically
- Still single host:port, but backend-aware

### Phase 3
- Backend discovery via config or protocol
- Multiple backends on different hosts/ports
- Per-backend configuration (auth, timeouts, etc.)

### Phase 4
- Substrate adds bare `schema` endpoint
- Synapse can connect to unknown backends
- Full dynamic discovery

## Transport Layer Changes

The `Substrate.Transport` module currently hardcodes `plexus.schema`:

```haskell
-- Current (substrate-protocol/src/Substrate/Transport.hs)
fetchSchemaAt cfg path = do
  let schemaMethod = if null path
        then "plexus.schema"  -- HARDCODED
        else T.intercalate "." path <> ".schema"
  ...
```

For Phase 2, this would become:

```haskell
-- Future
fetchSchemaAt cfg backend path = do
  let schemaMethod = if null path
        then backend <> ".schema"  -- DYNAMIC
        else T.intercalate "." path <> ".schema"
  ...
```

## CLI Changes

Current `Args` structure works for single backend. For multi-backend:

```haskell
data Args = Args
  { argHost    :: Text
  , argPort    :: Int
  , argBackend :: Maybe Text  -- NEW: explicit backend override
  , argPath    :: [Text]
  -- ...
  }
```

If `argBackend` is `Nothing`, first path segment is the backend name.
If `argBackend` is `Just b`, that's the backend (allows `synapse --backend plexus cone list`).

## Open Questions

1. **Default backend**: Should there be a default if no backend specified?
2. **Backend aliases**: Should `synapse p cone list` work as shorthand for `plexus`?
3. **Cross-backend calls**: Should `synapse plexus call agenthub.tasks.run` work?
4. **Backend-specific flags**: How to handle flags that only apply to certain backends?
