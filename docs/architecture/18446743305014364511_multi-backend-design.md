# Multi-Backend Architecture Design

## Current State (Phase 2 Implemented)

Synapse now requires a backend name as the first positional argument:

```
synapse [FLAGS] <backend> [PATH...]
```

Where:
- `synapse` — shows help (no backend specified)
- `synapse plexus` — shows plexus root schema
- `synapse plexus cone list` — navigates to `cone.list` method

### Key Components

**SynapseEnv** (`src/Synapse/Monad.hs`):
```haskell
data SynapseEnv = SynapseEnv
  { seHost    :: !Text
  , sePort    :: !Int
  , seBackend :: !Text    -- Backend name stored in environment
  , seCache   :: ...
  , seVisited :: ...
  }
```

**SubstrateConfig** (`substrate-protocol/src/Substrate/Client.hs`):
```haskell
data SubstrateConfig = SubstrateConfig
  { substrateHost    :: String
  , substratePort    :: Int
  , substratePath    :: String
  , substrateBackend :: Text    -- Backend name for RPC routing
  }
```

**Transport Layer** (`substrate-protocol/src/Substrate/Transport.hs`):
- All RPC calls use `<backend>.call` for routing
- Schema fetches use `<backend>.schema` for root
- No hardcoded "plexus" references

### Path Normalization

The `Navigate` module still strips the root namespace if it matches the first path segment:

```haskell
navigate target = do
  root <- fetchSchemaAt []
  let normalizedTarget = case target of
        (seg:rest) | seg == psNamespace root -> rest
        _ -> target
  withFreshVisited $ navigateFrom root [] normalizedTarget
```

This allows `synapse plexus plexus.cone` to work (strips redundant "plexus").

## Future: True Multi-Backend Discovery

### Required Protocol Change: Raw Schema Endpoint

Currently, fetching the root schema requires knowing the backend name in advance to call `<backend>.schema`. For true discovery:

**Proposed Substrate Enhancement:**

Add a bare `schema` method at the RPC level (no namespace prefix):

```json
// Current (requires knowing backend name)
{"jsonrpc":"2.0","id":1,"method":"plexus.schema","params":{}}

// Future (generic entry point)
{"jsonrpc":"2.0","id":1,"method":"schema","params":{}}
```

This would allow:
1. Connect to any backend on any port
2. Call bare `schema` to discover what's there
3. Use the returned `namespace` field to understand the backend identity

### Alternative: Backend Registry

A backend registry/discovery mechanism:

```json
{"jsonrpc":"2.0","id":1,"method":"backends","params":{}}
// Returns: ["plexus", "agenthub", "toolhub"]
```

## Implementation Phases

### Phase 1 (Complete)
- Flattened CLI structure
- Path normalization strips root namespace
- Hardcoded "plexus" in transport layer

### Phase 2 (Complete) ✓
- First arg parsed as backend name
- `argBackend` field in Args
- `seBackend` field in SynapseEnv
- `substrateBackend` field in SubstrateConfig
- Transport layer calls `<backend>.schema` dynamically
- All RPC routing uses `<backend>.call`

### Phase 3 (Future)
- Backend discovery via config or protocol
- Multiple backends on different hosts/ports
- Per-backend configuration (auth, timeouts, etc.)

### Phase 4 (Future)
- Substrate adds bare `schema` endpoint
- Synapse can connect to unknown backends
- Full dynamic discovery

## Files Changed in Phase 2

### synapse/app/Main.hs
- Added `argBackend :: Maybe Text` to Args
- Main dispatches on `argBackend`: Nothing → show help, Just → run
- `encodeDryRun` takes backend parameter

### synapse/src/Synapse/Monad.hs
- Added `seBackend :: !Text` to SynapseEnv
- `initEnv` takes backend parameter
- `defaultEnv` takes backend parameter

### synapse/src/Synapse/Transport.hs
- `getConfig` includes backend from environment

### substrate-protocol/src/Substrate/Client.hs
- Added `substrateBackend :: Text` to SubstrateConfig
- `defaultConfig` takes backend parameter

### substrate-protocol/src/Substrate/Transport.hs
- All functions use `substrateBackend cfg` instead of hardcoded "plexus"
- `fetchSchemaAt` calls `<backend>.schema`
- `invokeMethod` routes through `<backend>.call`
- `invokeRaw` routes through `<backend>.call`

## Open Questions

1. **Backend aliases**: Should `synapse p cone list` work as shorthand for `plexus`?
2. **Cross-backend calls**: Should `synapse plexus call agenthub.tasks.run` work?
3. **Backend-specific flags**: How to handle flags that only apply to certain backends?
4. **Default backend**: With bare `schema` endpoint, could auto-detect and default?
