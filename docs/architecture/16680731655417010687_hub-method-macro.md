# Hub Method Macro: Function-First Session Types

## Problem

The trait-based approach to session-typed methods (see `16680741769603549695_session-typed-methods.md`) works but feels wrong. It wraps functions in objects just to extract metadata:

```rust
// Current: Object-oriented ceremony
struct TreeGetMethod;

impl Method for TreeGetMethod {
    type Protocol = TreeGetProtocol;
    type ServerProtocol = <TreeGetProtocol as Session>::Dual;
    const NAME: &'static str = "tree_get";
    const DESCRIPTION: &'static str = "Get a tree by ID";
}

// Somewhere else, the actual implementation...
```

Problems:
1. **Indirection** - The function is hidden inside a trait impl
2. **Duplication** - Protocol defined separately from implementation
3. **Not composable** - Methods are objects, not functions
4. **Two sources of truth** - Schema describes the function, isn't derived from it

## Goal

**The function signature IS the schema.** The implementation is the source of truth. Everything else is derived.

```rust
#[hub_method]
async fn tree_get(input: TreeGetInput) -> Recv<TreeGetOutput, Done> {
    storage.get_tree(input.tree_id).await
}
```

This single definition provides:
- The callable handler
- The method name (from function name)
- The input schema (from parameter type)
- The protocol schema (from return type)
- The server protocol (dual, computed automatically)

## Design

### Basic Syntax

```rust
use hub_macro::hub_method;

/// Get a tree by ID
#[hub_method]
async fn tree_get(input: TreeGetInput) -> Recv<TreeGetOutput, Done> {
    let tree = storage.get_tree(input.tree_id).await?;
    Ok(TreeGetOutput { tree })
}
```

The macro extracts:
- **Name**: `tree_get` (function name, snake_case)
- **Description**: `"Get a tree by ID"` (from doc comment)
- **Input type**: `TreeGetInput` (from parameter)
- **Protocol**: `Recv<TreeGetOutput, Done>` (from return type, server perspective)
- **Client protocol**: `Send<TreeGetInput, Send<TreeGetOutput, Done>>` (prepend input, flip to client view)

### Override Name

```rust
#[hub_method(name = "arbor_tree_get")]
async fn tree_get(input: TreeGetInput) -> Recv<TreeGetOutput, Done> {
    // ...
}
```

### Streaming Protocol

```rust
/// Stream chat responses with content chunks
#[hub_method]
async fn chat(input: ChatInput) -> Session![
    send ChatStart;
    loop {
        choose {
            0 => { send ChatContent; continue; },
            1 => { send ChatComplete; break; },
        }
    }
] {
    // Server implementation uses the protocol directly
    // The session type enforces correct message ordering
}
```

From the server's perspective (which is what we implement):
- First receive `ChatInput` (implicit from parameter)
- Then send `ChatStart`
- Loop: choose to send `ChatContent` (continue) or `ChatComplete` (break)

The macro computes the client protocol (dual):
- Send `ChatInput`
- Receive `ChatStart`
- Loop: offer to receive `ChatContent` or `ChatComplete`

### Generated Code

For a simple method:

```rust
#[hub_method]
async fn tree_get(input: TreeGetInput) -> Recv<TreeGetOutput, Done> {
    // body
}
```

The macro generates:

```rust
// The original function, unchanged
async fn tree_get(input: TreeGetInput) -> Recv<TreeGetOutput, Done> {
    // body
}

// Schema extraction (const, computed at compile time conceptually)
impl __HubMethodSchema for tree_get {
    fn schema() -> MethodSchema {
        MethodSchema {
            name: "tree_get".to_string(),
            description: "Get a tree by ID".to_string(),
            // Client perspective: send input, then the return type's dual
            protocol: ProtocolSchema::Send {
                payload: schema_for!(TreeGetInput),
                then: Box::new(<Recv<TreeGetOutput, Done> as Session>::Dual::schema()),
            },
            // Server perspective: recv input, then the return type
            server_protocol: ProtocolSchema::Recv {
                payload: schema_for!(TreeGetInput),
                then: Box::new(<Recv<TreeGetOutput, Done>>::schema()),
            },
        }
    }
}

// Registration helper
inventory::submit! {
    HubMethodRegistration {
        name: "tree_get",
        schema: tree_get::schema,
        // handler binding...
    }
}
```

## Protocol Perspective

The key insight: **the function implements the server side**.

| Function Signature | Server Does | Client Does |
|-------------------|-------------|-------------|
| `fn(I) -> Recv<O, Done>` | recv I, send O | send I, recv O |
| `fn(I) -> Send<O, Done>` | recv I, recv O | send I, send O |
| `fn(I) -> Loop<Choose<...>>` | recv I, loop choosing | send I, loop offering |

The return type is the **server's protocol after receiving input**. The full server protocol is `Recv<Input, ReturnType>`. The client protocol is the dual.

## Schema Output

```json
{
  "name": "tree_get",
  "description": "Get a tree by ID",
  "protocol": {
    "type": "send",
    "payload": { "$ref": "#/$defs/TreeGetInput" },
    "then": {
      "type": "recv",
      "payload": { "$ref": "#/$defs/TreeGetOutput" },
      "then": { "type": "done" }
    }
  },
  "server_protocol": {
    "type": "recv",
    "payload": { "$ref": "#/$defs/TreeGetInput" },
    "then": {
      "type": "send",
      "payload": { "$ref": "#/$defs/TreeGetOutput" },
      "then": { "type": "done" }
    }
  }
}
```

## Activation Registration

```rust
// In activation module
mod methods {
    use hub_macro::hub_method;

    #[hub_method]
    pub async fn tree_get(input: TreeGetInput) -> Recv<TreeGetOutput, Done> { ... }

    #[hub_method]
    pub async fn tree_list() -> Recv<TreeListOutput, Done> { ... }

    #[hub_method]
    pub async fn tree_create(input: TreeCreateInput) -> Recv<TreeCreateOutput, Done> { ... }
}

// Activation collects all methods
pub struct ArborActivation;

impl Activation for ArborActivation {
    fn methods(&self) -> Vec<MethodSchema> {
        vec![
            methods::tree_get::schema(),
            methods::tree_list::schema(),
            methods::tree_create::schema(),
        ]
    }
}
```

Or with a collection macro:

```rust
#[hub_activation(namespace = "arbor")]
mod arbor {
    #[hub_method]
    pub async fn tree_get(...) -> ... { ... }

    #[hub_method]
    pub async fn tree_list(...) -> ... { ... }
}

// Generates ArborActivation with all methods collected
```

## No Input Case

Some methods take no input:

```rust
#[hub_method]
async fn tree_list() -> Recv<TreeListOutput, Done> {
    // ...
}
```

Protocol:
- Server: `Send<TreeListOutput, Done>` (no recv, just send)
- Client: `Recv<TreeListOutput, Done>`

## Error Handling

Errors are part of the protocol via `Either` or dedicated error types:

```rust
#[hub_method]
async fn tree_get(input: TreeGetInput) -> Recv<Result<TreeGetOutput, TreeGetError>, Done> {
    // ...
}
```

Or as protocol branches:

```rust
#[hub_method]
async fn tree_get(input: TreeGetInput) -> Choose<(
    Recv<TreeGetOutput, Done>,      // Success
    Recv<TreeGetError, Done>,       // Error
)> {
    // Server chooses which branch based on result
}
```

## Implementation Phases

### Phase 1: Proc Macro Crate

Create `hub-macro` crate with:
- `#[hub_method]` attribute macro
- Signature parsing
- Schema generation code emission
- Integration with existing `SessionSchema` trait

### Phase 2: Remove Trait-Based Methods

- Delete `Method` trait (or deprecate)
- Delete `typed_methods.rs` proof of concept
- Update `MethodCollection` to work with macro-generated schemas

### Phase 3: Migrate Existing Methods

Convert existing activation methods to use `#[hub_method]`:
- Arbor methods
- Cone methods
- Bash methods
- Health methods

### Phase 4: Activation Macro

- `#[hub_activation]` module-level macro
- Automatic method collection
- Namespace handling

## Comparison

| Aspect | Trait-Based (v1) | Macro-Based (v2) |
|--------|------------------|------------------|
| Definition | Struct + impl + type alias | Single function |
| Source of truth | Type alias | Function signature |
| Boilerplate | High | Minimal |
| Discoverability | Manual collection | Automatic via inventory |
| Composability | Object-like | Function-like |
| Implementation | Separate from schema | IS the schema |

## Open Questions

1. **Context passing**: How does the function access storage, config, etc.?
   - Parameter: `fn tree_get(ctx: &Ctx, input: TreeGetInput) -> ...`
   - Implicit: Thread-local or async context
   - Method: `impl Arbor { #[hub_method] async fn tree_get(&self, ...) }`

2. **Async streams**: How to express the actual streaming body?
   - Return `impl Stream<Item = ...>` that satisfies the session type?
   - Use dialectic's channel types directly in the body?

3. **Error handling**: Protocol-level errors vs Rust errors?
   - `Result<T, E>` in payload types
   - `Choose` branches for success/error paths
   - Both?

## References

- [Session-Typed Methods (v1)](./16680741769603549695_session-typed-methods.md) - Trait-based approach
- [Servant (Haskell)](https://docs.servant.dev/) - Type-level API definitions
- [Dialectic](https://docs.rs/dialectic) - Session types for Rust
- [inventory](https://docs.rs/inventory) - Distributed plugin registration
