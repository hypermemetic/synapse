# Session-Typed Methods with Dialectic

## Overview

This document describes an architecture for RPC methods that use session types to enforce protocol correctness at compile time while enabling full runtime schema introspection for client codegen.

## Problem Statement

The current architecture has a gap between:
1. **Method definitions** (input schemas) - exposed via introspection
2. **Response types** (output events) - exist but not introspectable
3. **Protocol structure** (streaming patterns) - implicit in implementation

Methods like `cone_chat` have complex streaming protocols:
```
Client sends input → Server sends ChatStart → Server sends ChatContent* → Server sends ChatComplete
```

This protocol is enforced only by convention, not by types. The relationship between input and output types exists only in the implementation body.

## Solution: Session Types + Schema Extraction

Use the `dialectic` crate for session types combined with a `SessionSchema` trait for runtime introspection.

### Core Insight

Session types encode the protocol in the type system:
```rust
type ConeChatProtocol = Session! {
    send ChatInput;          // Client sends input
    recv ChatStart;          // Server sends start event
    loop {
        offer {
            0 => { recv ChatContent; continue; },  // More content
            1 => { recv ChatComplete; break; },    // Terminal
        }
    }
};
```

The compiler enforces:
- Correct message ordering
- All branches handled
- Protocol completed

And critically: **the type IS the schema**. We can extract it at runtime.

## Architecture

### SessionSchema Trait

Extracts protocol schema from session types:

```rust
/// Runtime representation of a session protocol
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ProtocolSchema {
    Send { payload: Value, then: Box<ProtocolSchema> },
    Recv { payload: Value, then: Box<ProtocolSchema> },
    Offer { branches: Vec<ProtocolSchema> },
    Choose { branches: Vec<ProtocolSchema> },
    Loop { body: Box<ProtocolSchema> },
    Continue { depth: usize },
    Done,
}

/// Extract schema from a session type
pub trait SessionSchema {
    fn schema() -> ProtocolSchema;
}

// Implemented for all dialectic primitives
impl SessionSchema for Done { ... }
impl<T: JsonSchema, P: SessionSchema> SessionSchema for Send<T, P> { ... }
impl<T: JsonSchema, P: SessionSchema> SessionSchema for Recv<T, P> { ... }
impl<P: SessionSchema> SessionSchema for Loop<P> { ... }
impl<Choices: Tuple> SessionSchema for Offer<Choices> where Choices::AsList: ListSchema { ... }
impl<Choices: Tuple> SessionSchema for Choose<Choices> where Choices::AsList: ListSchema { ... }
impl SessionSchema for Continue<N> { ... }
```

### Method Trait

Methods are defined by their protocol:

```rust
/// A typed RPC method with session-type protocol
pub trait Method: Send + Sync + 'static {
    /// The session protocol for this method (from client's perspective)
    type Protocol: Session + SessionSchema;

    /// Method name for RPC routing
    const NAME: &'static str;

    /// Execute the method on a session-typed channel
    async fn execute<Tx, Rx>(
        &self,
        chan: Chan<Self::Protocol, Tx, Rx>,
        ctx: &ActivationContext,
    ) -> Result<(), MethodError>
    where
        Tx: Transmit<...>,
        Rx: Receive<...>;

    /// Get the full method schema (protocol + payload types)
    fn schema() -> MethodSchema {
        MethodSchema {
            name: Self::NAME.to_string(),
            protocol: <Self::Protocol as SessionSchema>::schema(),
            // Dual is automatic
            server_protocol: <<Self::Protocol as Session>::Dual as SessionSchema>::schema(),
        }
    }
}
```

### Example: Simple Request-Response

```rust
/// Get a tree by ID
struct TreeGet;

type TreeGetProtocol = Session! {
    send TreeGetInput;
    recv TreeData;
};

#[derive(Serialize, Deserialize, JsonSchema)]
struct TreeGetInput {
    tree_id: Uuid,
}

#[derive(Serialize, Deserialize, JsonSchema)]
struct TreeData {
    tree: Tree,
}

impl Method for TreeGet {
    type Protocol = TreeGetProtocol;
    const NAME: &'static str = "tree_get";

    async fn execute<Tx, Rx>(
        &self,
        chan: Chan<Self::Protocol, Tx, Rx>,
        ctx: &ActivationContext,
    ) -> Result<(), MethodError> {
        // Receive input (from client's send)
        let (input, chan) = chan.recv().await?;

        // Get tree from storage
        let tree = ctx.storage.get_tree(input.tree_id).await?;

        // Send response (client will recv)
        chan.send(TreeData { tree }).await?;

        Ok(())
    }
}
```

Generated schema:
```json
{
  "name": "tree_get",
  "protocol": {
    "type": "send",
    "payload": { "title": "TreeGetInput", "properties": { "tree_id": { "format": "uuid" } } },
    "then": {
      "type": "recv",
      "payload": { "title": "TreeData", "properties": { "tree": { "$ref": "#/$defs/Tree" } } },
      "then": { "type": "done" }
    }
  },
  "server_protocol": {
    "type": "recv",
    "payload": { "title": "TreeGetInput", ... },
    "then": {
      "type": "send",
      "payload": { "title": "TreeData", ... },
      "then": { "type": "done" }
    }
  }
}
```

### Example: Streaming Response

```rust
/// Chat with LLM - streams response tokens
struct ConeChat;

type ConeChatProtocol = Session! {
    send ChatInput;
    recv ChatStart;
    loop {
        offer {
            0 => { recv ChatContent; continue; },
            1 => { recv ChatComplete; break; },
        }
    }
};

#[derive(Serialize, Deserialize, JsonSchema)]
struct ChatInput {
    cone_id: Uuid,
    prompt: String,
}

#[derive(Serialize, Deserialize, JsonSchema)]
struct ChatStart {
    cone_id: Uuid,
    user_position: Position,
}

#[derive(Serialize, Deserialize, JsonSchema)]
struct ChatContent {
    cone_id: Uuid,
    content: String,
}

#[derive(Serialize, Deserialize, JsonSchema)]
struct ChatComplete {
    cone_id: Uuid,
    new_head: Position,
    usage: Option<ChatUsage>,
}

impl Method for ConeChat {
    type Protocol = ConeChatProtocol;
    const NAME: &'static str = "cone_chat";

    async fn execute<Tx, Rx>(
        &self,
        chan: Chan<Self::Protocol, Tx, Rx>,
        ctx: &ActivationContext,
    ) -> Result<(), MethodError> {
        // Server implements the DUAL protocol
        // Recv input
        let (input, chan) = chan.recv().await?;

        // Send start
        let chan = chan.send(ChatStart { ... }).await?;

        // Stream content in a loop
        let mut chan = chan;
        let mut stream = ctx.llm.chat_stream(input).await?;

        while let Some(token) = stream.next().await {
            // Choose branch 0: send content, continue
            chan = chan.choose::<0>().await?
                       .send(ChatContent { content: token, ... }).await?;
        }

        // Choose branch 1: send complete, break
        chan.choose::<1>().await?
            .send(ChatComplete { ... }).await?;

        Ok(())
    }
}
```

Generated schema:
```json
{
  "name": "cone_chat",
  "protocol": {
    "type": "send",
    "payload": { "title": "ChatInput", ... },
    "then": {
      "type": "recv",
      "payload": { "title": "ChatStart", ... },
      "then": {
        "type": "loop",
        "body": {
          "type": "offer",
          "branches": [
            {
              "type": "recv",
              "payload": { "title": "ChatContent", ... },
              "then": { "type": "continue", "depth": 0 }
            },
            {
              "type": "recv",
              "payload": { "title": "ChatComplete", ... },
              "then": { "type": "done" }
            }
          ]
        }
      }
    }
  }
}
```

### Activation Integration

```rust
pub trait Activation: Send + Sync + 'static {
    /// All methods provided by this activation
    type Methods: MethodCollection;

    fn namespace(&self) -> &str;
    fn version(&self) -> &str;

    /// Get schema for all methods
    fn schema(&self) -> ActivationSchema {
        ActivationSchema {
            namespace: self.namespace().to_string(),
            version: self.version().to_string(),
            methods: Self::Methods::schemas(),
        }
    }
}

/// Collection of methods (could be generated by macro)
pub trait MethodCollection {
    fn schemas() -> Vec<MethodSchema>;
    fn route(name: &str) -> Option<Box<dyn Method>>;
}

// Example implementation
struct ArborMethods;

impl MethodCollection for ArborMethods {
    fn schemas() -> Vec<MethodSchema> {
        vec![
            TreeGet::schema(),
            TreeCreate::schema(),
            TreeList::schema(),
            NodeCreateText::schema(),
            // ...
        ]
    }

    fn route(name: &str) -> Option<Box<dyn Method>> {
        match name {
            "tree_get" => Some(Box::new(TreeGet)),
            "tree_create" => Some(Box::new(TreeCreate)),
            // ...
            _ => None,
        }
    }
}
```

## Introspection API

The schema endpoint returns complete protocol information:

```rust
// plexus_activation_schema("arbor") returns:
{
  "namespace": "arbor",
  "version": "1.0.0",
  "methods": [
    {
      "name": "tree_get",
      "protocol": {
        "type": "send",
        "payload": { /* TreeGetInput schema */ },
        "then": {
          "type": "recv",
          "payload": { /* TreeData schema */ },
          "then": { "type": "done" }
        }
      }
    },
    {
      "name": "cone_chat",
      "protocol": {
        "type": "send",
        "payload": { /* ChatInput schema */ },
        "then": {
          "type": "recv",
          "payload": { /* ChatStart schema */ },
          "then": {
            "type": "loop",
            "body": {
              "type": "offer",
              "branches": [
                { "type": "recv", "payload": { /* ChatContent */ }, "then": { "type": "continue" } },
                { "type": "recv", "payload": { /* ChatComplete */ }, "then": { "type": "done" } }
              ]
            }
          }
        }
      }
    }
  ]
}
```

## Client Codegen

With the full protocol schema, codegen can produce:

### 1. Type Definitions

Extract all unique payload types from the protocol:
```haskell
-- From send/recv payloads in protocol
data TreeGetInput = TreeGetInput { treeId :: UUID }
data TreeData = TreeData { tree :: Tree }
data ChatInput = ChatInput { coneId :: UUID, prompt :: Text }
data ChatStart = ChatStart { coneId :: UUID, userPosition :: Position }
data ChatContent = ChatContent { coneId :: UUID, content :: Text }
data ChatComplete = ChatComplete { coneId :: UUID, newHead :: Position, usage :: Maybe ChatUsage }
```

### 2. Protocol State Machine

Generate a state machine type from the protocol:
```haskell
-- From protocol structure
data TreeGetState
  = TreeGetSendInput
  | TreeGetRecvData
  | TreeGetDone

data ConeChatState
  = ConeChatSendInput
  | ConeChatRecvStart
  | ConeChatLoop ConeChatLoopState
  | ConeChatDone

data ConeChatLoopState
  = AwaitingOffer
  | ReceivedContent
  | ReceivedComplete
```

### 3. Typed Functions

Generate functions that enforce the protocol:
```haskell
-- Simple request-response
treeGet :: PlexusConnection -> TreeGetInput -> IO TreeData
treeGet conn input = do
  chan <- openChannel conn "arbor_tree_get"
  chan' <- send chan input
  (response, _) <- recv chan'
  pure response

-- Streaming with callback
coneChat :: PlexusConnection -> ChatInput -> (ChatEvent -> IO ()) -> IO ChatComplete
coneChat conn input onEvent = do
  chan <- openChannel conn "cone_chat"
  chan' <- send chan input
  (start, chan'') <- recv chan'
  onEvent (EventStart start)
  loop chan''
  where
    loop chan = do
      branch <- offer chan
      case branch of
        Left contentChan -> do
          (content, chan') <- recv contentChan
          onEvent (EventContent content)
          loop chan'
        Right completeChan -> do
          (complete, _) <- recv completeChan
          pure complete
```

### 4. Event Sum Types (Per-Method)

Generate method-specific event types:
```haskell
-- Only events possible from this method
data ConeChatEvent
  = ConeChatStart ChatStart
  | ConeChatContent ChatContent
  | ConeChatComplete ChatComplete
```

## Benefits

### Compile-Time Safety

The compiler enforces:
- ✅ Correct message types at each step
- ✅ All offer branches handled
- ✅ Protocol completes (no dangling channels)
- ✅ Dual relationship automatic

```rust
// This won't compile - wrong order
async fn bad_execute(chan: Chan<TreeGetProtocol, ...>) {
    chan.send(TreeData { ... }).await?;  // ERROR: expected recv, got send
}

// This won't compile - missing branch
async fn bad_streaming(chan: Chan<ConeChatProtocol, ...>) {
    let (input, chan) = chan.recv().await?;
    chan.send(ChatStart { ... }).await?;
    // ERROR: protocol not complete, loop not handled
}
```

### Runtime Introspection

Full schema extraction enables:
- ✅ Dynamic CLI generation
- ✅ Client codegen in any language
- ✅ Protocol documentation
- ✅ Validation tooling

### Single Source of Truth

Protocol defined once, derived everywhere:
- Server implementation types
- Client types (via codegen)
- API documentation
- Validation rules

## Implementation Plan

### Phase 1: SessionSchema Trait

1. Create `session_schema` module with `ProtocolSchema` enum
2. Implement `SessionSchema` for all dialectic primitives
3. Add tests for schema extraction

**Estimated: ~200 lines**

### Phase 2: Method Trait

1. Define `Method` trait with `Protocol` associated type
2. Implement for one method (e.g., `TreeGet`) as proof of concept
3. Verify schema generation

**Estimated: ~150 lines**

### Phase 3: Activation Integration

1. Create `MethodCollection` trait
2. Macro for deriving `MethodCollection` from method list
3. Update `Activation` trait to use methods
4. Update `plexus_activation_schema` endpoint

**Estimated: ~300 lines**

### Phase 4: Migration

1. Convert existing methods one-by-one
2. Each method gains:
   - Session type definition
   - Protocol enforcement
   - Schema extraction
3. Deprecate old untyped methods

**Estimated: ~100 lines per method**

### Phase 5: Client Codegen

1. Parse protocol schemas
2. Extract payload types
3. Generate state machine types
4. Generate typed functions

**Estimated: ~500 lines (Haskell codegen)**

## Dependencies

```toml
[dependencies]
dialectic = { version = "0.4", features = ["tokio"] }
schemars = { version = "1.0", features = ["derive"] }
```

## Proof of Concept

The `SessionSchema` trait has been validated in `/tmp/dialectic_explore/`. Key findings:

1. ✅ Schema extraction works for all session type primitives
2. ✅ Works with `Session!` macro-generated types
3. ✅ Dual types work automatically
4. ✅ Nested loops and offers handled correctly
5. ✅ JSON Schema embedded for each payload type

### Working Implementation

```rust
use dialectic::prelude::*;
use dialectic::types::{Done, Loop, Offer, Recv, Send, Choose, Continue};
use schemars::{schema_for, JsonSchema};
use serde::{Deserialize, Serialize};
use serde_json::Value;

// ============================================================================
// Protocol Schema Types - describes the shape of a session protocol
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ProtocolSchema {
    /// Send a value of this type, then continue
    Send {
        payload: Value,
        then: Box<ProtocolSchema>,
    },
    /// Receive a value of this type, then continue
    Recv {
        payload: Value,
        then: Box<ProtocolSchema>,
    },
    /// Offer multiple branches (server waits for client choice)
    Offer {
        branches: Vec<ProtocolSchema>,
    },
    /// Choose from multiple branches (client selects)
    Choose {
        branches: Vec<ProtocolSchema>,
    },
    /// Loop construct
    Loop {
        body: Box<ProtocolSchema>,
    },
    /// Continue to Nth enclosing loop
    Continue {
        depth: usize,
    },
    /// Session complete
    Done,
}

// ============================================================================
// SessionSchema Trait - extracts schema from session types
// ============================================================================

pub trait SessionSchema {
    fn schema() -> ProtocolSchema;
}

// Done - terminal
impl SessionSchema for Done {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Done
    }
}

// Send<T, P> - send T then continue with P
impl<T: JsonSchema + 'static, P: SessionSchema + 'static> SessionSchema for Send<T, P> {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Send {
            payload: serde_json::to_value(schema_for!(T)).unwrap(),
            then: Box::new(P::schema()),
        }
    }
}

// Recv<T, P> - receive T then continue with P
impl<T: JsonSchema + 'static, P: SessionSchema + 'static> SessionSchema for Recv<T, P> {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Recv {
            payload: serde_json::to_value(schema_for!(T)).unwrap(),
            then: Box::new(P::schema()),
        }
    }
}

// Loop<P> - loop over P
impl<P: SessionSchema + 'static> SessionSchema for Loop<P> {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Loop {
            body: Box::new(P::schema()),
        }
    }
}

// Continue<N> - continue to Nth enclosing loop
impl SessionSchema for Continue<0> {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Continue { depth: 0 }
    }
}

impl SessionSchema for Continue<1> {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Continue { depth: 1 }
    }
}

impl SessionSchema for Continue<2> {
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Continue { depth: 2 }
    }
}

// For Offer and Choose, we need to handle the tuple structure
// Dialectic uses flat tuples (A, B) externally but converts to (A, (B, ())) internally

// Helper trait for extracting schemas from inductive type-level lists
pub trait ListSchema {
    fn schemas() -> Vec<ProtocolSchema>;
}

// Base case: empty list
impl ListSchema for () {
    fn schemas() -> Vec<ProtocolSchema> {
        vec![]
    }
}

// Inductive case: (Head, Tail)
impl<P: SessionSchema + 'static, Rest: ListSchema + 'static> ListSchema for (P, Rest) {
    fn schemas() -> Vec<ProtocolSchema> {
        let mut v = vec![P::schema()];
        v.extend(Rest::schemas());
        v
    }
}

// Offer<Choices> - offer multiple branches
use dialectic::tuple::Tuple;

impl<Choices> SessionSchema for Offer<Choices>
where
    Choices: Tuple + 'static,
    Choices::AsList: ListSchema,
{
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Offer {
            branches: <Choices::AsList as ListSchema>::schemas(),
        }
    }
}

// Choose<Choices> - choose from branches
impl<Choices> SessionSchema for Choose<Choices>
where
    Choices: Tuple + 'static,
    Choices::AsList: ListSchema,
{
    fn schema() -> ProtocolSchema {
        ProtocolSchema::Choose {
            branches: <Choices::AsList as ListSchema>::schemas(),
        }
    }
}

// ============================================================================
// Test Types
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ChatInput {
    pub cone_id: String,
    pub prompt: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ChatStart {
    pub cone_id: String,
    pub user_position: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ChatContent {
    pub cone_id: String,
    pub content: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ChatComplete {
    pub cone_id: String,
    pub new_head: String,
}

// ============================================================================
// Test Protocols
// ============================================================================

// Simple: send input, receive output
type SimpleProtocol = Session! {
    send ChatInput;
    recv ChatComplete;
};

// Streaming: send input, receive start, loop(content | complete), done
type StreamingProtocol = Session! {
    send ChatInput;
    recv ChatStart;
    loop {
        offer {
            0 => { recv ChatContent; continue; },
            1 => { recv ChatComplete; break; },
        }
    }
};

fn main() {
    println!("=== Simple Protocol Schema ===");
    let simple_schema = <Send<ChatInput, Recv<ChatComplete, Done>>>::schema();
    println!("{}", serde_json::to_string_pretty(&simple_schema).unwrap());

    println!("\n=== Streaming Protocol Schema (using Session! macro) ===");
    let streaming_schema = <StreamingProtocol>::schema();
    println!("{}", serde_json::to_string_pretty(&streaming_schema).unwrap());

    println!("\n=== Simple Protocol Dual ===");
    type ServerSimple = <SimpleProtocol as Session>::Dual;
    let server_schema = <ServerSimple>::schema();
    println!("Server (dual) protocol:");
    println!("{}", serde_json::to_string_pretty(&server_schema).unwrap());

    println!("\n=== Streaming Protocol Dual (Server side) ===");
    type ServerStreaming = <StreamingProtocol as Session>::Dual;
    let server_streaming_schema = <ServerStreaming>::schema();
    println!("Server streaming protocol:");
    println!("{}", serde_json::to_string_pretty(&server_streaming_schema).unwrap());
}
```

### Sample Output

Running the above produces:

```
=== Simple Protocol Schema ===
{
  "type": "send",
  "payload": {
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "properties": {
      "cone_id": { "type": "string" },
      "prompt": { "type": "string" }
    },
    "required": ["cone_id", "prompt"],
    "title": "ChatInput",
    "type": "object"
  },
  "then": {
    "type": "recv",
    "payload": {
      "properties": {
        "cone_id": { "type": "string" },
        "new_head": { "type": "string" }
      },
      "required": ["cone_id", "new_head"],
      "title": "ChatComplete",
      "type": "object"
    },
    "then": { "type": "done" }
  }
}

=== Streaming Protocol Dual (Server side) ===
{
  "type": "recv",
  "payload": { "title": "ChatInput", ... },
  "then": {
    "type": "send",
    "payload": { "title": "ChatStart", ... },
    "then": {
      "type": "loop",
      "body": {
        "type": "choose",
        "branches": [
          {
            "type": "send",
            "payload": { "title": "ChatContent", ... },
            "then": { "type": "continue", "depth": 0 }
          },
          {
            "type": "send",
            "payload": { "title": "ChatComplete", ... },
            "then": { "type": "done" }
          }
        ]
      }
    }
  }
}
```

Note how the dual automatically flips:
- `send` ↔ `recv`
- `offer` ↔ `choose`

The protocol structure (loop, branching) remains the same, but the direction of each operation is reversed.

## References

- [Dialectic crate](https://docs.rs/dialectic) - Session types for Rust
- [Session Types](https://groups.inf.ed.ac.uk/abcd/) - Academic background
- [Introspective RPC Protocol](./16680807091363337727_introspective-rpc-protocol.md) - Wire protocol
- [Client Codegen Requirements](./16680785784679922687_client-codegen-requirements.md) - Codegen analysis
