# Namespace Refactoring for IR Types

## Overview

This document describes the refactoring of how namespaces are handled in the IR (Intermediate Representation) used by both Synapse (Haskell CLI) and hub-codegen (TypeScript generator).

## Problem

Previously, type names in the IR included their namespace as a dot-separated prefix:
- `cone.ListResult`
- `arbor.TreeInfo`
- `cone.ConeIdentifier`

This created issues for TypeScript code generation where we want per-namespace modules with local type names.

## Solution

Separate the namespace from the type name using a dedicated `tdNamespace` field, with `tdFullName` computed when needed.

### Synapse IR Changes (Haskell)

**File: `src/Synapse/IR/Types.hs`**

```haskell
data TypeDef = TypeDef
  { tdName        :: Text           -- ^ Local type name (e.g., "ListResult")
  , tdNamespace   :: Text           -- ^ Namespace (e.g., "cone")
  , tdDescription :: Maybe Text
  , tdKind        :: TypeKind
  }

-- Computed full name for Map keys and deduplication
tdFullName :: TypeDef -> Text
tdFullName td = tdNamespace td <> "." <> tdName td
```

**File: `src/Synapse/IR/Builder.hs`**

- `extractTypeDef` now takes namespace as parameter and populates `tdNamespace`
- Map keys still use `tdFullName` for uniqueness
- `RefNamed` references continue using full qualified names for lookup

### Hub-Codegen IR Changes (Rust)

**File: `hub-codegen/src/ir.rs`**

```rust
pub struct TypeDef {
    pub td_name: String,        // Local name
    pub td_namespace: String,   // Namespace
    pub td_description: Option<String>,
    pub td_kind: TypeKind,
}

impl TypeDef {
    pub fn full_name(&self) -> String {
        format!("{}.{}", self.td_namespace, self.td_name)
    }
}

// Helper to split qualified names
pub fn split_qualified_name(name: &str) -> (Option<&str>, &str) {
    if let Some(dot_pos) = name.find('.') {
        (Some(&name[..dot_pos]), &name[dot_pos + 1..])
    } else {
        (None, name)
    }
}
```

### TypeScript Generation Changes

**Per-Namespace Module Structure:**

```
generated/
├── index.ts              # Re-exports namespace modules
├── types.ts              # Shared/core types
├── rpc.ts                # RPC layer
├── transport.ts          # WebSocket transport
├── cone/
│   ├── index.ts          # Re-exports types + client
│   ├── types.ts          # Cone-specific types (local names)
│   └── client.ts         # Typed client for cone methods
├── arbor/
│   ├── index.ts
│   ├── types.ts
│   └── client.ts
└── ...
```

**Key Changes in Generators:**

1. `types.rs`: Added `generate_namespace_types()` that produces `<namespace>/types.ts` files
2. `namespaces.rs`: Changed output structure from `<namespace>.ts` to `<namespace>/client.ts`
3. Added `to_ts_in_namespace()` method on `TypeRef` for context-aware type name resolution
4. Types within their own namespace use local names; cross-namespace references use qualified names

## Impact Analysis

### Synapse CLI - No Breaking Changes

The Synapse CLI is unaffected because:

1. **Map Lookups**: `RefNamed` still uses full qualified names (e.g., `"cone.ListResult"`)
2. **IR Building**: Uses `tdFullName` for Map keys, preserving uniqueness
3. **Help/Support**: Added `KindStringEnum` case to pattern matches (bug fix)

### TypeScript Generation - Improved Structure

The generated TypeScript now has:
- Better module organization (per-namespace folders)
- Local type names within namespace modules
- Proper imports between namespaces when needed

## Additional Fixes

### KindStringEnum Pattern Match

Added missing `KindStringEnum` case to:
- `src/Synapse/CLI/Help.hs:expandTypeDef` - String enums don't expand (just literals)
- `src/Synapse/CLI/Support.hs:canCLIRepresentTypeDef` - String enums are CLI-representable

### Test Backend Argument

Updated `test/IRSpec.hs` to require backend as CLI argument instead of environment variable:

```bash
cabal test ir-test --test-options="<backend>"
```

This follows the principle that backend names should never be hardcoded or defaulted.

## Testing

### Synapse Tests
```bash
cabal test ir-test --test-options="plexus"
# All 13 tests pass
```

### TypeScript Generation
```bash
cabal run synapse -- --emit-ir plexus > /tmp/ir.json
cd hub-codegen && cargo run -- /tmp/ir.json -o /tmp/generated
```

## Migration

No migration needed. The changes are internal to the IR representation and maintain backward compatibility with existing interfaces.
