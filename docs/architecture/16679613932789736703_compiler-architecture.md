# Compiler Architecture: From IR to Typed Clients

**Status**: Design
**Scope**: Full-stack client generation pipeline
**Date**: 2024-12-30

## Executive Summary

This document outlines the architecture for generating fully-typed clients from the Plexus IR. The goal is a **fully automatic** pipeline where changes to Rust backend types propagate to generated clients without manual intervention.

```
Rust types → hub-macro → Schema → IR → Transpiler → TypeScript/Python/Swift
```

## Current State

### What We Have

```
┌─────────────────────────────────────────────────────────────┐
│ Plexus (Rust)                                               │
│ ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│ │ Rust Types  │───▶│ hub-macro   │───▶│ JSON Schema │      │
│ │ + schemars  │    │             │    │ per method  │      │
│ └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ Synapse (Haskell)                                           │
│ ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│ │ Schema Walk │───▶│ IR Builder  │───▶│ JSON IR     │      │
│ │ (hyloM)     │    │             │    │ (emitted)   │      │
│ └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│ Transpiler (NOT YET BUILT)                                  │
│ ┌─────────────┐    ┌─────────────┐    ┌─────────────┐      │
│ │ IR Parser   │───▶│ Code Gen    │───▶│ TS/Py/Swift │      │
│ │             │    │             │    │ Client      │      │
│ └─────────────┘    └─────────────┘    └─────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### What's Missing from the IR

The current IR captures **type structure** but not **protocol semantics**:

| Missing | Why It Matters |
|---------|----------------|
| Transport type | WebSocket vs HTTP/SSE vs stdio affects client architecture |
| Protocol format | JSON-RPC 2.0 encoding not specified |
| Base URL / endpoints | Where to connect |
| Authentication | How to authenticate |
| Subscription semantics | How streaming methods work (JSON-RPC subscriptions vs SSE) |
| Error codes | Standard error shapes for typed catch blocks |
| Retry policy | Which methods are idempotent |

## Proposed IR Extensions

### 1. Transport Metadata

Add a top-level `transport` section:

```json
{
  "irVersion": "2.0",
  "transport": {
    "protocols": ["jsonrpc-ws", "jsonrpc-http", "mcp-sse"],
    "default": "jsonrpc-ws",
    "endpoints": {
      "jsonrpc-ws": "ws://{host}:{port}/",
      "jsonrpc-http": "http://{host}:{port}/rpc",
      "mcp-sse": "http://{host}:{port}/mcp"
    }
  },
  "irTypes": { ... },
  "irMethods": { ... }
}
```

### 2. Protocol Encoding

Methods need protocol-specific metadata:

```json
{
  "cone.chat": {
    "mdName": "chat",
    "mdStreaming": true,
    "mdProtocol": {
      "jsonrpc": {
        "method": "plexus_call",
        "params": { "method": "cone.chat", "params": "{params}" },
        "subscription": true
      },
      "mcp": {
        "tool": "cone.chat"
      }
    },
    "mdParams": [...],
    "mdReturns": "ChatEvent"
  }
}
```

### 3. Error Type Standardization

Currently each method has an `error` variant in its return union. Standardize this:

```json
{
  "irErrors": {
    "PlexusError": {
      "discriminator": "code",
      "variants": {
        "not_found": { "message": "string" },
        "invalid_params": { "message": "string", "details": "any" },
        "internal": { "message": "string" },
        "transport": { "message": "string" }
      }
    }
  }
}
```

Then methods reference error types:

```json
{
  "cone.chat": {
    "mdReturns": "ChatEvent",
    "mdErrors": ["not_found", "internal"]
  }
}
```

### 4. Authentication Metadata

```json
{
  "auth": {
    "type": "none" | "bearer" | "api_key",
    "header": "Authorization",
    "prefix": "Bearer "
  }
}
```

## TypeScript Transpiler Design

### Output Structure

```
generated/
├── types.ts           # All type definitions
├── client.ts          # PlexusClient class
├── methods/
│   ├── cone.ts        # cone.* methods
│   ├── arbor.ts       # arbor.* methods
│   └── index.ts       # Re-exports
├── transport/
│   ├── jsonrpc.ts     # JSON-RPC encoding
│   ├── websocket.ts   # WebSocket transport
│   └── sse.ts         # SSE transport
└── index.ts           # Main export
```

### Type Generation

**Input (IR):**
```json
{
  "Position": {
    "tdKind": {
      "tag": "KindStruct",
      "ksFields": [
        { "fdName": "tree_id", "fdType": { "tag": "RefNamed", "contents": "UUID" } },
        { "fdName": "node_id", "fdType": { "tag": "RefNamed", "contents": "UUID" } }
      ]
    }
  }
}
```

**Output (TypeScript):**
```typescript
/** A position in the context tree */
export interface Position {
  /** The tree containing this position */
  tree_id: UUID;
  /** The specific node within the tree */
  node_id: UUID;
}
```

### Discriminated Union Generation

**Input (IR):**
```json
{
  "ChatEvent": {
    "tdKind": {
      "tag": "KindEnum",
      "keDiscriminator": "type",
      "keVariants": [
        { "vdName": "chat_start", "vdFields": [...] },
        { "vdName": "chat_content", "vdFields": [...] },
        { "vdName": "chat_complete", "vdFields": [...] },
        { "vdName": "error", "vdFields": [...] }
      ]
    }
  }
}
```

**Output (TypeScript):**
```typescript
export type ChatEvent =
  | ChatEvent_ChatStart
  | ChatEvent_ChatContent
  | ChatEvent_ChatComplete
  | ChatEvent_Error;

export interface ChatEvent_ChatStart {
  type: "chat_start";
  cone_id: UUID;
  user_position: Position;
}

export interface ChatEvent_ChatContent {
  type: "chat_content";
  cone_id: UUID;
  content: string;
}

export interface ChatEvent_ChatComplete {
  type: "chat_complete";
  cone_id: UUID;
  new_head: Position;
  usage?: ChatUsage;
}

export interface ChatEvent_Error {
  type: "error";
  message: string;
}

// Type guard helpers
export function isChatStart(e: ChatEvent): e is ChatEvent_ChatStart {
  return e.type === "chat_start";
}
// ... etc
```

### Method Generation

**For non-streaming methods:**

```typescript
export interface ConeCreateParams {
  name: string;
  model_id: string;
  system_prompt?: string | null;
  metadata?: unknown;
}

export async function coneCreate(
  client: PlexusClient,
  params: ConeCreateParams
): Promise<CreateResult> {
  const response = await client.call("cone.create", params);
  return response as CreateResult;
}
```

**For streaming methods:**

```typescript
export interface ConeChatParams {
  identifier: ConeIdentifier;
  prompt: string;
  ephemeral?: boolean | null;
}

export async function* coneChat(
  client: PlexusClient,
  params: ConeChatParams
): AsyncGenerator<ChatEvent, void, unknown> {
  for await (const event of client.subscribe("cone.chat", params)) {
    yield event as ChatEvent;
  }
}
```

### Transport Layer

**WebSocket + JSON-RPC:**

```typescript
export class PlexusClient {
  private ws: WebSocket;
  private pending: Map<number, { resolve: Function; reject: Function }>;
  private subscriptions: Map<number, (data: unknown) => void>;
  private nextId = 1;

  constructor(url: string) {
    this.ws = new WebSocket(url);
    this.ws.onmessage = this.handleMessage.bind(this);
  }

  async call(method: string, params: unknown): Promise<unknown> {
    const id = this.nextId++;
    return new Promise((resolve, reject) => {
      this.pending.set(id, { resolve, reject });
      this.ws.send(JSON.stringify({
        jsonrpc: "2.0",
        id,
        method: "plexus_call",
        params: { method, params }
      }));
    });
  }

  async *subscribe(method: string, params: unknown): AsyncGenerator<unknown> {
    const id = this.nextId++;
    const queue: unknown[] = [];
    let resolve: (() => void) | null = null;
    let done = false;

    this.subscriptions.set(id, (data) => {
      if (data.type === "done") {
        done = true;
        resolve?.();
      } else {
        queue.push(data);
        resolve?.();
      }
    });

    this.ws.send(JSON.stringify({
      jsonrpc: "2.0",
      id,
      method: "plexus_call",  // Subscription method
      params: { method, params }
    }));

    while (!done) {
      if (queue.length > 0) {
        yield queue.shift()!;
      } else {
        await new Promise<void>(r => resolve = r);
      }
    }

    this.subscriptions.delete(id);
  }
}
```

## Reliability Improvements

### 1. Schema Validation at Build Time

Before generating code, validate the IR:

```typescript
function validateIR(ir: IR): ValidationResult {
  const errors: string[] = [];

  // Check all type references resolve
  for (const [name, method] of Object.entries(ir.irMethods)) {
    const returnType = method.mdReturns;
    if (returnType.tag === "RefNamed" && !ir.irTypes[returnType.contents]) {
      errors.push(`Method ${name} references unknown type ${returnType.contents}`);
    }
  }

  // Check discriminated unions have discriminator field
  for (const [name, type] of Object.entries(ir.irTypes)) {
    if (type.tdKind.tag === "KindEnum") {
      for (const variant of type.tdKind.keVariants) {
        // Verify discriminator value is present
      }
    }
  }

  return { valid: errors.length === 0, errors };
}
```

### 2. Round-Trip Testing

Generate a test suite that verifies generated types match runtime behavior:

```typescript
// Generated test
describe("cone.chat", () => {
  it("should parse chat_start event", () => {
    const raw = { type: "chat_start", cone_id: "...", user_position: {...} };
    const parsed = parseChatEvent(raw);
    expect(isChatStart(parsed)).toBe(true);
  });

  it("should serialize params correctly", () => {
    const params: ConeChatParams = { identifier: {...}, prompt: "test" };
    const serialized = serializeConeChatParams(params);
    // Validate against JSON Schema
  });
});
```

### 3. Version Compatibility

Use IR hash for cache invalidation:

```typescript
// generated/meta.ts
export const IR_VERSION = "1.0";
export const IR_HASH = "449f272b6a97dd94";  // From plexus.hash

// At runtime
const serverHash = await client.call("plexus.hash", {});
if (serverHash !== IR_HASH) {
  console.warn("Client generated from different schema version");
}
```

### 4. Incremental Generation

Only regenerate changed types:

```typescript
interface GenerationCache {
  typeHashes: Map<string, string>;  // Type name -> content hash
  methodHashes: Map<string, string>;
}

function generateIncremental(ir: IR, cache: GenerationCache): GeneratedFiles {
  const changed: string[] = [];

  for (const [name, type] of Object.entries(ir.irTypes)) {
    const hash = hashType(type);
    if (cache.typeHashes.get(name) !== hash) {
      changed.push(name);
    }
  }

  // Only regenerate changed types and dependent methods
}
```

## Stack-Level Changes Needed

### Plexus (Rust)

1. **Add `#[streaming]` attribute** to hub-macro for explicit streaming declaration
2. **Expose transport metadata** via `plexus.transport` method
3. **Standardize error codes** across all activations
4. **Add method metadata** (idempotent, deprecated, etc.)

```rust
#[hub_methods]
impl Cone {
    #[streaming]
    #[doc = "Chat with a cone"]
    async fn chat(&self, ...) -> impl Stream<Item = ChatEvent> { ... }

    #[idempotent]
    async fn get(&self, ...) -> GetResult { ... }
}
```

### Synapse (Haskell)

1. **Extend IR with transport info** - fetch from new `plexus.transport` endpoint
2. **Add error type extraction** - pull error variants into separate section
3. **Include protocol encoding hints** - JSON-RPC method paths, MCP tool names

### Transpilers

1. **TypeScript** - Primary target, WebSocket + optional SSE
2. **Python** - asyncio, httpx/websockets
3. **Swift** - Combine/async-await, URLSession

## Transpiler Implementation Sketch (TypeScript)

### Phase 1: IR Parsing

```typescript
// src/ir.ts
interface IR {
  irVersion: string;
  irTypes: Record<string, TypeDef>;
  irMethods: Record<string, MethodDef>;
  irPlugins: Record<string, string[]>;
}

function parseIR(json: string): IR {
  return JSON.parse(json) as IR;
}
```

### Phase 2: Type Generation

```typescript
// src/generators/types.ts
function generateType(name: string, def: TypeDef): string {
  switch (def.tdKind.tag) {
    case "KindStruct":
      return generateStruct(name, def);
    case "KindEnum":
      return generateEnum(name, def);
    case "KindPrimitive":
      return generateAlias(name, def);
    case "KindAlias":
      return generateAlias(name, def);
  }
}

function generateStruct(name: string, def: TypeDef): string {
  const fields = def.tdKind.ksFields.map(f => {
    const optional = !f.fdRequired ? "?" : "";
    const type = typeRefToTS(f.fdType);
    const doc = f.fdDescription ? `  /** ${f.fdDescription} */\n` : "";
    return `${doc}  ${f.fdName}${optional}: ${type};`;
  });

  const doc = def.tdDescription ? `/** ${def.tdDescription} */\n` : "";
  return `${doc}export interface ${name} {\n${fields.join("\n")}\n}`;
}

function typeRefToTS(ref: TypeRef): string {
  switch (ref.tag) {
    case "RefNamed": return ref.contents;
    case "RefPrimitive": return primitiveToTS(ref.contents[0], ref.contents[1]);
    case "RefArray": return `${typeRefToTS(ref.contents)}[]`;
    case "RefOptional": return `${typeRefToTS(ref.contents)} | null`;
    case "RefUnknown": return "unknown";
  }
}

function primitiveToTS(type: string, format: string | null): string {
  if (type === "string" && format === "uuid") return "string"; // Could be branded
  if (type === "string") return "string";
  if (type === "integer" || type === "number") return "number";
  if (type === "boolean") return "boolean";
  return "unknown";
}
```

### Phase 3: Method Generation

```typescript
// src/generators/methods.ts
function generateMethod(name: string, def: MethodDef): string {
  const paramsType = `${pascalCase(def.mdName)}Params`;
  const returnType = typeRefToTS(def.mdReturns);

  // Generate params interface
  const paramsInterface = generateParamsInterface(paramsType, def.mdParams);

  // Generate function
  const fn = def.mdStreaming
    ? generateStreamingMethod(name, def, paramsType, returnType)
    : generateCallMethod(name, def, paramsType, returnType);

  return `${paramsInterface}\n\n${fn}`;
}

function generateStreamingMethod(
  name: string,
  def: MethodDef,
  paramsType: string,
  returnType: string
): string {
  return `
/**
 * ${def.mdDescription || name}
 */
export async function* ${camelCase(def.mdName)}(
  client: PlexusClient,
  params: ${paramsType}
): AsyncGenerator<${returnType}, void, unknown> {
  for await (const event of client.subscribe("${def.mdFullPath}", params)) {
    yield event as ${returnType};
  }
}`;
}
```

### Phase 4: Client Generation

```typescript
// src/generators/client.ts
function generateClient(ir: IR): string {
  const methods = Object.entries(ir.irMethods)
    .map(([name, def]) => generateClientMethod(name, def))
    .join("\n\n");

  return `
import { WebSocket } from "ws";

export interface PlexusClientOptions {
  url: string;
  onError?: (error: Error) => void;
}

export class PlexusClient {
  private ws: WebSocket;
  private nextId = 1;
  private pending = new Map<number, { resolve: Function; reject: Function }>();
  private subscriptions = new Map<number, (data: unknown) => void>();

  constructor(private options: PlexusClientOptions) {
    this.ws = new WebSocket(options.url);
    this.ws.on("message", this.handleMessage.bind(this));
  }

  // ... transport methods ...

${methods}
}`;
}
```

### Phase 5: CLI Tool

```typescript
// src/cli.ts
import { program } from "commander";
import { readFileSync, writeFileSync, mkdirSync } from "fs";

program
  .name("plexus-codegen")
  .argument("<ir-file>", "Path to IR JSON file")
  .option("-o, --output <dir>", "Output directory", "./generated")
  .option("--transport <type>", "Transport type", "websocket")
  .action((irFile, options) => {
    const ir = JSON.parse(readFileSync(irFile, "utf-8"));

    mkdirSync(options.output, { recursive: true });

    // Generate types
    const types = generateAllTypes(ir);
    writeFileSync(`${options.output}/types.ts`, types);

    // Generate client
    const client = generateClient(ir);
    writeFileSync(`${options.output}/client.ts`, client);

    // Generate methods
    const methods = generateAllMethods(ir);
    writeFileSync(`${options.output}/methods.ts`, methods);

    console.log(`Generated client in ${options.output}`);
  });

program.parse();
```

## Full Pipeline

```bash
# 1. Start Plexus
cargo run --bin substrate

# 2. Generate IR
synapse --emit-ir > ir.json

# 3. Generate TypeScript client
plexus-codegen ir.json -o ./ts-client

# 4. Use generated client
import { PlexusClient, coneChat, ChatEvent } from "./ts-client";

const client = new PlexusClient({ url: "ws://localhost:4444" });

for await (const event of coneChat(client, {
  identifier: { by_name: "my-agent" },
  prompt: "Hello!"
})) {
  if (event.type === "chat_content") {
    process.stdout.write(event.content);
  }
}
```

## Open Questions

1. **Branded types vs plain types?** Should `UUID` be `string` or `string & { __brand: "UUID" }`?

2. **Error handling strategy?** Throw exceptions or return Result<T, E>?

3. **Runtime validation?** Generate zod/io-ts schemas for runtime checking?

4. **Monorepo or separate packages?** One package or `@plexus/types`, `@plexus/client`, etc.?

5. **Hot reloading?** Watch IR file and regenerate on change?

6. **Multiple transports in one client?** Support both WebSocket and HTTP?

## Implementation Order

1. **Week 1**: Extend IR with transport metadata (Synapse)
2. **Week 2**: TypeScript type generator (basic structs + enums)
3. **Week 3**: TypeScript method generator (call + subscribe)
4. **Week 4**: WebSocket transport + client class
5. **Week 5**: CLI tool + integration testing
6. **Week 6**: Python transpiler (reuse IR, new code gen)

## Success Criteria

- [ ] Change a Rust type → regenerate → TypeScript compiles
- [ ] Generated client can call all methods
- [ ] Streaming methods yield correctly typed events
- [ ] Type guards work for discriminated unions
- [ ] Hash mismatch detected at runtime
- [ ] Zero manual edits needed in generated code
