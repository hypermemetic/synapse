# `_self` Command Namespace for Synapse Meta-Operations

**Status**: Proposed
**Created**: 2026-01-21
**Author**: Human + Claude

## Problem Statement

Currently, Synapse is purely a Plexus RPC frontend - all commands route through `synapse plexus <activation> <method>`. There's no mechanism for synapse-level introspection, tooling, or meta-operations that don't involve calling Plexus.

**Missing capabilities:**
- Generating example usage/templates from schemas
- Synapse-level configuration or diagnostics
- Schema analysis and exploration
- Code generation or documentation tools
- CLI self-help utilities beyond basic `--help`

**Why not add to Plexus?** These are client-side concerns that shouldn't require round-tripping to the backend. Templates, examples, and schema exploration should work offline and not depend on a running Plexus instance.

## Solution: `_self` Command Namespace

Introduce a special activation namespace `_self` for synapse-level commands:

```bash
synapse _self <command> [args...]
```

The underscore prefix signals:
1. This is NOT a Plexus activation
2. Executes locally in Synapse (no RPC)
3. Meta-level tooling for Synapse itself

## Initial Command: `_self template`

Generate example command-line invocations from Plexus schemas.

### Motivation

New users (especially LLMs!) need to learn Plexus APIs. Currently they must:
1. Run `--help` to see parameters
2. Manually construct valid invocations
3. Guess at object structures and types

**What if Synapse could show examples?**

```bash
# Show template for a specific method
$ synapse _self template plexus.cone.create

synapse plexus cone create \
  --model_id "claude-sonnet-4-5-20250929" \
  --name "my-cone" \
  --metadata '{}' \
  --system_prompt "You are helpful"

# Show templates for all cone methods
$ synapse _self template plexus.cone.*

# Regex matching
$ synapse _self template plexus.*.create
```

### Design Principles

**1. Pattern Matching with Regex**

Users should be able to discover methods via patterns:
- Exact: `plexus.cone.create`
- Wildcard: `plexus.cone.*` → all cone methods
- Regex: `plexus.*.create` → all create methods across activations
- Complex: `plexus.(cone|arbor).list` → list methods in cone and arbor

**2. Bounded Output with `--limit`**

Regex patterns could match hundreds of methods. Control output size:

```bash
# Default: show first 10 matches
$ synapse _self template plexus.*.*

# Show up to 50
$ synapse _self template plexus.*.* --limit 50

# Range: show matches 20-30 (for pagination)
$ synapse _self template plexus.*.* --limit.lower 20 --limit.upper 30
```

**Limit behavior:**
- **Default**: 10 results
- **`--limit N`**: Show first N results
- **`--limit.lower N --limit.upper M`**: Show results N through M (0-indexed)
- **Exceeds limit**: Display warning: `"Showing 10 of 47 matches. Use --limit to see more."`

**3. Template Generation from Schema**

For each method, generate a valid example invocation:

```bash
synapse plexus <activation> <method> \
  --required_param <type_example> \
  --optional_param <type_example>
```

**Type examples:**
- `string` → `"example"`
- `integer` → `42`
- `boolean` → `true`
- `uuid` → `"550e8400-e29b-41d4-a716-446655440000"`
- `object` → `'{}'` or show structure
- `enum` → first valid value
- Complex nested types → minimal valid JSON

**4. Output Format**

```bash
$ synapse _self template plexus.cone.create

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
plexus.cone.create
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Description:
  Create a new cone (LLM agent with persistent conversation context)

Template:
  synapse plexus cone create \
    --model_id "claude-sonnet-4-5-20250929" \
    --name "my-cone" \
    --system_prompt "You are helpful" \
    --metadata '{}'

Required Parameters:
  • model_id: LLM model ID
  • name: Human-readable name

Optional Parameters:
  • system_prompt: System instructions
  • metadata: Configuration metadata

Try it:
  synapse plexus cone create --model_id "claude-sonnet-4-5" --name "test"
```

Multiple matches should be separated with dividers.

## Architecture

### Command Routing

```
User: synapse _self template plexus.cone.*
  ↓
Main.hs: Parse command line
  ↓
Check first arg == "_self"?
  ├─ Yes → Route to SelfCommands module
  │         ↓
  │         Parse subcommand ("template")
  │         ↓
  │         Execute locally (NO RPC)
  │         ↓
  │         Output to stdout
  │
  └─ No → Normal Plexus RPC path
```

### Module Structure

```haskell
Synapse.Self
  ├── Commands.hs        -- Command dispatcher
  ├── Template.hs        -- Template generation
  ├── Pattern.hs         -- Regex pattern matching
  └── Examples.hs        -- Type → example value mapping
```

### Data Flow

```
1. Load Plexus schema (from cache or query)
   ↓
2. Parse method pattern (regex)
   ↓
3. Match against all method paths
   ↓
4. Apply limit bounds
   ↓
5. For each match:
   - Generate template from schema
   - Format output
   ↓
6. Display to user
```

## Future `_self` Commands

The `_self` namespace enables many future utilities:

### Schema Exploration
```bash
# Find all methods returning a specific type
synapse _self schema find-return-type TreeId

# Show full schema for a method
synapse _self schema show plexus.cone.chat

# Export schema as JSON/YAML
synapse _self schema export --format yaml
```

### Code Generation
```bash
# Generate TypeScript client code
synapse _self codegen typescript --output ./client.ts

# Generate Rust examples
synapse _self codegen examples --lang rust
```

### Diagnostics
```bash
# Test Plexus connection
synapse _self health

# Show synapse version and config
synapse _self info

# Benchmark schema loading time
synapse _self bench schema-load
```

### Configuration
```bash
# Set default Plexus URL
synapse _self config set plexus-url ws://localhost:4444

# Show current configuration
synapse _self config show
```

## Implementation Considerations

### 1. Schema Caching

Templates depend on schemas. Options:
- **Cache schemas locally** → Fast, works offline
- **Query on-demand** → Always fresh, requires connection
- **Hybrid**: Cache with TTL, refresh when stale

**Recommendation**: Cache schemas in `~/.synapse/schema-cache/` with timestamps.

### 2. Pattern Matching Performance

With hundreds of methods, regex matching could be slow.

**Optimizations**:
- Pre-build method index on schema load
- Use compiled regex patterns
- Short-circuit on exact matches
- Limit regex complexity (timeout after 100ms)

### 3. Template Quality

Generated templates should be **immediately runnable** with minor edits.

**Quality criteria**:
- Use realistic example values (not just "string")
- Show common patterns (e.g., ConeIdentifier structure)
- Include inline comments for complex parameters
- Validate generated templates compile against schema

### 4. Error Handling

```bash
# No matches
$ synapse _self template plexus.nonexistent.*
No methods match pattern: plexus.nonexistent.*

# Invalid regex
$ synapse _self template plexus.(cone
Invalid regex pattern: plexus.(cone
  Unclosed group

# Schema unavailable
$ synapse _self template plexus.cone.create
Error: Schema not available (Plexus not running)
Try: synapse plexus --schema cone  # Fetch schema first
```

## User Experience Goals

**For humans:**
- Discover APIs faster than reading docs
- Copy-paste examples that actually work
- Learn by example instead of memorizing syntax

**For LLMs:**
- Self-serve API discovery without asking humans
- Generate valid commands from patterns
- Understand parameter structures from examples

**For developers:**
- Validate schemas produce sensible templates
- Debug parameter issues with concrete examples
- Generate documentation automatically

## Success Metrics

A successful `_self template` implementation should:

1. **Cover 100% of Plexus methods** - Every method has a template
2. **Templates are valid** - Generated commands parse successfully
3. **Fast pattern matching** - Regex matches complete in <100ms
4. **Useful examples** - Example values are realistic, not just placeholders
5. **Discovery-friendly** - Wildcards and regex enable exploration

## Open Questions

1. **Template variants?** Should we show multiple examples per method (minimal vs. full)?
2. **Language targeting?** Should templates be bash-only or also show curl/websocat equivalents?
3. **Interactive mode?** Could `_self template` drop into an interactive prompt?
4. **Integration with `--help`?** Should regular help output link to `_self template`?

## Relationship to Existing Work

**Complements**:
- Existing `--help` shows schema → `_self template` shows examples
- Existing `--schema` dumps JSON → `_self template` makes it actionable
- TypeScript docs in substrate-sandbox-ts → `_self` could generate these

**Differs from**:
- Plexus activations (server-side) → `_self` is client-side
- Normal CLI invocations → `_self` doesn't make RPC calls

## Naming Rationale

**Why `_self`?**
- Underscore clearly signals "special/meta"
- Common in programming (e.g., Python's `self`, Rust's `Self`)
- Short and memorable
- Won't conflict with Plexus activations (valid identifiers don't start with `_`)

**Why not:**
- `synapse self` → Looks like Plexus activation
- `synapse --internal` → Awkward flag-based routing
- `synapse meta` → Too generic
- `synapse.template` → Doesn't generalize to other commands

## Next Steps

1. ✅ Write this architecture document
2. ⏳ Create implementation plan
3. ⏳ Implement command routing for `_self`
4. ⏳ Implement `template` command with regex matching
5. ⏳ Add limit/pagination support
6. ⏳ Generate quality example values for common types
7. ⏳ Write tests for pattern matching and template generation
8. ⏳ Update main help to mention `_self` commands
9. ⏳ Gather user feedback and iterate

---

**This architecture enables Synapse to become more than just an RPC frontend - it becomes a complete CLI toolkit for Plexus development and exploration.**
