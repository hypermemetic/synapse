# Substrate JSON-RPC Protocol

## Overview

Substrate exposes its activations via JSON-RPC 2.0 over WebSocket. All methods are **subscriptions** that stream events back to the client.

## Connection

```
WebSocket: ws://127.0.0.1:4444
```

## Request Format

```json
{
  "jsonrpc": "2.0",
  "id": <integer>,
  "method": "<namespace>_<method>",
  "params": [<positional>, <args>]
}
```

Method names follow the pattern `{namespace}_{method}`:
- `health_check`
- `bash_execute`
- `arbor_tree_create`, `arbor_tree_get`, `arbor_node_create_text`, etc.
- `cone_create`, `cone_chat`, `cone_list`, etc.

## Response Format

### 1. Subscription Acknowledgment

Immediately after subscribing, the server returns the subscription ID:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": 5591949794125159
}
```

### 2. Streaming Events

Events are pushed as notifications with the subscription ID:

```json
{
  "jsonrpc": "2.0",
  "method": "<original_method>",
  "params": {
    "subscription": 5591949794125159,
    "result": {
      "event": "data",
      "data": {
        "provenance": {"segments": ["<activation>"]},
        "content_type": "<activation>.event",
        "data": { ... activation-specific payload ... }
      }
    }
  }
}
```

### 3. Done Event

When the stream completes:

```json
{
  "jsonrpc": "2.0",
  "method": "<original_method>",
  "params": {
    "subscription": 5591949794125159,
    "result": {
      "event": "done",
      "data": {
        "provenance": {"segments": ["<activation>"]}
      }
    }
  }
}
```

## Activation Methods

### Health (`health`)

| Method | Params | Description |
|--------|--------|-------------|
| `health_check` | `[]` | Returns health status and uptime |

**Response payload:**
```json
{"status": "healthy", "type": "status", "uptime_seconds": 1042}
```

### Bash (`bash`)

| Method | Params | Description |
|--------|--------|-------------|
| `bash_execute` | `[command: string]` | Execute shell command, stream output |

**Response payloads:**
```json
{"type": "stdout", "line": "hello world"}
{"type": "stderr", "line": "error message"}
{"type": "exit", "code": 0}
```

### Arbor (`arbor`)

Tree structure storage for conversation context.

| Method | Params | Description |
|--------|--------|-------------|
| `arbor_tree_create` | `[metadata: object \| null, owner_id: string]` | Create new tree |
| `arbor_tree_get` | `[tree_id: string]` | Get tree with root info |
| `arbor_tree_list` | `[]` | List all tree IDs |
| `arbor_tree_delete` | `[tree_id: string]` | Delete a tree |
| `arbor_node_create_text` | `[tree_id, parent_id, content, metadata]` | Create text node |
| `arbor_node_create_external` | `[tree_id, parent_id, handle, metadata]` | Create external reference node |
| `arbor_node_get` | `[tree_id, node_id]` | Get node details |
| `arbor_context_get_path` | `[tree_id, node_id]` | Get path from root to node |

**Example payloads:**
```json
// tree_created
{"type": "tree_created", "tree_id": "uuid"}

// tree_data
{"type": "tree_data", "tree": {"id": "uuid", "root": "uuid", ...}}

// node_created
{"type": "node_created", "node_id": "uuid"}

// context_path
{"type": "context_path", "nodes": [...]}
```

### Cone (`cone`)

LLM conversation orchestration with arbor context.

| Method | Params | Description |
|--------|--------|-------------|
| `cone_create` | `[name, model_id, system_prompt \| null, metadata \| null]` | Create new cone |
| `cone_get` | `[cone_id: string]` | Get cone config |
| `cone_list` | `[]` | List all cones |
| `cone_delete` | `[cone_id: string]` | Delete a cone |
| `cone_chat` | `[cone_id, prompt]` | Chat with cone (streams response) |
| `cone_set_head` | `[cone_id, node_id]` | Move context head |

**Chat streaming payloads:**
```json
// Start
{"type": "chat_start", "cone_id": "uuid", "user_position": {...}}

// Content chunks (multiple)
{"type": "chat_content", "cone_id": "uuid", "content": "Hello"}

// Complete
{"type": "chat_complete", "cone_id": "uuid", "new_head": {...}, "usage": {...}}
```

## Example Session

```
Client → Server:
{"jsonrpc":"2.0","id":1,"method":"arbor_tree_create","params":[{"test":true},"owner"]}

Server → Client:
{"jsonrpc":"2.0","id":1,"result":123456789}

Server → Client:
{"jsonrpc":"2.0","method":"arbor_tree_create","params":{"subscription":123456789,"result":{"event":"data","data":{"provenance":{"segments":["arbor"]},"content_type":"arbor.event","data":{"type":"tree_created","tree_id":"abc-123"}}}}}

Server → Client:
{"jsonrpc":"2.0","method":"arbor_tree_create","params":{"subscription":123456789,"result":{"event":"done","data":{"provenance":{"segments":["arbor"]}}}}}
```

## Integration Tests

See `substrate/tests/rpc_integration.rs` for working examples:

```rust
// Health check
client.subscribe::<Value, _>("health_check", rpc_params![], "unsubscribe_check")

// Bash execute
client.subscribe::<Value, _>("bash_execute", rpc_params!["echo hello"], "unsubscribe_execute")

// Arbor tree create
client.subscribe::<Value, _>(
    "arbor_tree_create",
    rpc_params![json!({"test": true}), "owner"],
    "unsubscribe_tree_create",
)

// Cone create
client.subscribe::<Value, _>(
    "cone_create",
    rpc_params!["name", "gpt-4o-mini", "System prompt", json!(null)],
    "unsubscribe_create",
)
```

Run tests with:
```bash
# Start server first
cargo run

# In another terminal
cargo test --test rpc_integration -- --test-threads=1
```

## Provenance

Every event includes a `provenance` field tracking the origin:

```json
{"segments": ["arbor"]}           // Direct from arbor
{"segments": ["cone", "arbor"]}   // Cone called arbor internally
```

This enables filtering and debugging of nested activation calls.

## Error Handling

Errors are returned as JSON-RPC errors:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "code": -32602,
    "message": "Invalid params: missing 'command' field"
  }
}
```

Or as stream events:

```json
{
  "event": "error",
  "data": {
    "provenance": {"segments": ["cone"]},
    "error": "Failed to get agent: not found",
    "recoverable": false
  }
}
```
