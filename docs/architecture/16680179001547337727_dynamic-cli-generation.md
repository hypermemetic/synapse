# Dynamic CLI Generation Architecture

Synapse generates its CLI at runtime by querying schema endpoints and building `optparse-applicative` parsers from JSON Schema definitions.

## Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Startup Flow                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  1. plexus_hash        →  Check if cache is fresh                           │
│  2. plexus_schema      →  Get activation list + method names                │
│  3. plexus_full_schema →  Get params/returns JSON Schema per activation     │
│                                                                              │
│  Cache: .substrate/cache/schema.json                                         │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Parser Construction                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  PlexusSchema                        ActivationFullSchema                    │
│  ├─ activations: [ActivationInfo]    ├─ namespace: "cone"                   │
│  │   ├─ namespace: "cone"            ├─ methods: [MethodSchemaInfo]         │
│  │   ├─ methods: ["chat","list"]     │   ├─ name: "chat"                    │
│  │   └─ description: "..."           │   ├─ params: { JSON Schema }         │
│  └─ total_methods: 42                │   └─ returns: { JSON Schema }        │
│                                                                              │
│                         buildDynamicParserWithSchemas                        │
│                                      │                                       │
│                                      ▼                                       │
│                          Parser CommandInvocation                            │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Key Types

### Schema Types (from `meaning` package)

```haskell
-- Plexus.Schema

-- Top-level schema from plexus_schema
data PlexusSchema = PlexusSchema
  { schemaActivations  :: [ActivationInfo]
  , schemaTotalMethods :: Int
  }

-- Single activation metadata
data ActivationInfo = ActivationInfo
  { activationNamespace   :: Text      -- "arbor", "cone", "bash"
  , activationVersion     :: Text      -- "1.0.0"
  , activationDescription :: Text      -- Human-readable
  , activationMethods     :: [Text]    -- ["chat", "list", "create"]
  }

-- Full schema from plexus_full_schema (includes JSON Schema)
data ActivationFullSchema = ActivationFullSchema
  { fullSchemaNamespace   :: Text
  , fullSchemaVersion     :: Text
  , fullSchemaDescription :: Text
  , fullSchemaMethods     :: [MethodSchemaInfo]
  }

-- Method with params and returns JSON Schema
data MethodSchemaInfo = MethodSchemaInfo
  { methodInfoName        :: Text
  , methodInfoDescription :: Text
  , methodInfoParams      :: Maybe Value   -- JSON Schema for params
  , methodInfoReturns     :: Maybe Value   -- JSON Schema for return events
  }
```

### Parser Types (from `Plexus.Dynamic`)

```haskell
-- Result of parsing CLI arguments
data CommandInvocation = CommandInvocation
  { invMethod :: Text    -- "cone_chat"
  , invParams :: Value   -- {"identifier":{"by_name":{"name":"x"}},"prompt":"hi"}
  }

-- Parameter type (parsed from JSON Schema "type" field)
data ParamType
  = ParamString
  | ParamInteger
  | ParamNumber
  | ParamBoolean
  | ParamObject
  | ParamArray ParamType
  | ParamNullable ParamType

-- Parameter schema (extracted from JSON Schema)
data ParamSchema = ParamSchema
  { paramName     :: Text
  , paramType     :: ParamType
  , paramFormat   :: Maybe Text    -- "uuid", etc.
  , paramRequired :: Bool
  , paramDesc     :: Maybe Text
  , paramDefault  :: Maybe Value
  }
```

## Parser Construction Pipeline

### Entry Point

```haskell
buildDynamicParserWithSchemas
  :: PlexusSchema
  -> Map Text ActivationFullSchema
  -> Parser CommandInvocation
```

This builds a nested subparser:

```
synapse
├── cone                    (activation subcommand)
│   ├── chat               (method subcommand)
│   │   ├── --id TEXT
│   │   ├── --prompt TEXT
│   │   └── --ephemeral TEXT
│   ├── list
│   └── create
├── arbor
│   ├── tree-list
│   └── tree-create
└── bash
    └── execute
```

### Per-Activation Parser

```haskell
buildActivationParserWithFullSchema
  :: ActivationInfo
  -> Maybe ActivationFullSchema
  -> Parser CommandInvocation
```

For each method in `activationMethods`:
1. Look up `MethodSchemaInfo` by name from `fullSchemaMethods`
2. If `methodInfoParams` exists → `buildTypedMethodParserFromParams`
3. Otherwise → `buildMethodParser` (generic `--params JSON`)

### Per-Method Typed Parser

```haskell
buildTypedMethodParserFromParams
  :: Text      -- namespace
  -> Text      -- method
  -> Value     -- JSON Schema for params
  -> Parser CommandInvocation
```

Steps:
1. `extractSchemaInfo` → `(Map Text Value, [Text])` (properties, required)
2. Sort params: required first, then optional
3. For each property, `buildParamParserFromSchema` based on type
4. Combine into `Parser [(Text, Maybe Value)]`
5. Wrap in `CommandInvocation` with `buildParamsObject`

### JSON Schema → Parser Flag

```haskell
buildParamParserFromSchema
  :: [Text]              -- required field names
  -> (Text, Value)       -- (param name, JSON Schema)
  -> Parser (Text, Maybe Value)
```

Type mapping:

| JSON Schema `type` | Haskell Parser           | Metavar  |
|--------------------|--------------------------|----------|
| `"string"`         | `strOption :: Parser String` | `TEXT`   |
| `"integer"`        | `option auto :: Parser Int`  | `INT`    |
| `"number"`         | `option auto :: Parser Double` | `NUM`  |
| `"boolean"`        | `switch :: Parser Bool`  | (none)   |
| object/array       | `strOption` (raw JSON)   | `JSON`   |

### Smart Transformations

#### ConeIdentifier Detection

```haskell
smartConeIdentifier :: String -> Value
smartConeIdentifier input
  | looksLikeUUID (T.pack input) = object
      [ "by_id" .= object ["id" .= input] ]
  | otherwise = object
      [ "by_name" .= object ["name" .= input] ]

looksLikeUUID :: Text -> Bool
-- Checks 8-4-4-4-12 hex pattern
```

This transforms `--id haiku-test` into:
```json
{"by_name": {"name": "haiku-test"}}
```

And `--id 550e8400-e29b-41d4-a716-446655440000` into:
```json
{"by_id": {"id": "550e8400-e29b-41d4-a716-446655440000"}}
```

#### Parameter Aliases

```haskell
applyParamAlias :: Text -> Text
applyParamAlias "identifier" = "id"  -- --identifier → --id
applyParamAlias name = name
```

#### Name Conversion

```haskell
toFlagName :: Text -> String
-- snake_case → kebab-case with alias
-- "owner_id" → "owner-id"
-- "identifier" → "id"

toCommandName :: Text -> String
-- snake_case → kebab-case
-- "tree_create" → "tree-create"
```

## Help Text Generation

Help text is pulled from JSON Schema `description` fields:

```haskell
helpText = maybe ("Parameter: " <> nameStr) T.unpack desc
  where
    desc = case schema of
      Object o -> case KM.lookup "description" o of
        Just (String s) -> Just s
        _ -> Nothing
```

Example output:
```
--id TEXT        Cone name or UUID (e.g., 'my-assistant' or '550e8400-e29b-...')
--prompt TEXT    User message / prompt to send to the LLM
```

## Execution Flow

```
┌──────────────────────────────────────────────────────────────┐
│  User: synapse cone chat --id haiku --prompt "hello"         │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  1. Parse global opts (--host, --port, --json, etc.)         │
│  2. Load schema (cache or fetch)                             │
│  3. Build dynamic parser from schema                         │
│  4. Parse remaining args → CommandInvocation                 │
│     { invMethod = "cone_chat"                                │
│     , invParams = {"identifier":{"by_name":{"name":"haiku"}} │
│                   ,"prompt":"hello"}                         │
│     }                                                        │
└──────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  5. Connect to Plexus WebSocket                              │
│  6. plexusRpc conn "cone_chat" params                        │
│  7. Stream PlexusStreamItem events                           │
│  8. Render each event (schema-aware or template)             │
└──────────────────────────────────────────────────────────────┘
```

## Cache Structure

```
.substrate/cache/schema.json
{
  "hash": "abc123...",
  "schema": { PlexusSchema },
  "fullSchemas": {
    "cone": { ActivationFullSchema },
    "arbor": { ActivationFullSchema },
    ...
  }
}
```

Cache invalidation: compare `plexus_hash` result with stored hash.

## Design Decisions

### Why Runtime Discovery?

- **Single source of truth**: Backend defines API, CLI follows
- **No code generation step**: Just restart CLI to pick up changes
- **Versioning**: Schema includes version per activation

### Why optparse-applicative?

- **Composable**: Parsers combine with `<*>` and `subparser`
- **Help generation**: Auto-generates `--help` from parser structure
- **Type-safe**: Parser results are statically typed

### Fallback Strategy

```
1. Try typed parser from full schema params
2. Fall back to generic --params JSON
3. Fall back to positional args as JSON array
```

This ensures CLI always works even if schema fetch fails.
