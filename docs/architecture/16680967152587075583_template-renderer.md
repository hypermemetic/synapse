# Template-Based Output Renderer

Runtime-configurable output rendering using Handlebars templates that map JSON Schema responses to human-readable output.

## Key Features

1. **Template Metadata** - Templates specify which endpoint they handle via YAML front matter
2. **Schema Discovery** - `--schema` flag dumps the JSON schema for any method
3. **Runtime Loading** - Templates can be added/modified without recompiling

## Overview

The CLI receives structured JSON from RPC methods. Rather than hardcoding formatters, we use Handlebars templates that can be:

1. **Shipped** - Built-in defaults for common output
2. **User-configured** - `~/.config/symbols/templates/`
3. **Project-local** - `.substrate/templates/`

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLI Pipeline                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   RPC Response (JSON)                                           │
│         │                                                       │
│         ▼                                                       │
│   ┌─────────────┐                                               │
│   │ TemplateResolver                                            │
│   │  - lookupTemplate :: Method -> Maybe Template               │
│   │  - searchPaths :: [FilePath]                                │
│   └──────┬──────┘                                               │
│          │                                                      │
│          ▼                                                      │
│   ┌─────────────┐     ┌──────────────┐                          │
│   │ Renderer    │────▶│ Handlebars   │                          │
│   │  - render   │     │ Engine       │                          │
│   └──────┬──────┘     └──────────────┘                          │
│          │                                                      │
│          ▼                                                      │
│   Formatted Output (Text)                                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Template Resolution

### Search Order

```haskell
templateSearchPaths :: IO [FilePath]
templateSearchPaths = do
  cwd <- getCurrentDirectory
  home <- getHomeDirectory
  pure
    [ cwd </> ".substrate" </> "templates"      -- 1. Project-local
    , home </> ".config" </> "symbols" </> "templates"  -- 2. User global
    -- 3. Built-in (embedded in binary)
    ]
```

### Template Naming Convention

```
{namespace}/{method}.hbs
```

Examples:
- `arbor/tree-list.hbs`
- `arbor/tree-get.hbs`
- `cone/registry.hbs`
- `cone/chat.hbs`

### Fallback Chain

```haskell
resolveTemplate :: Text -> Text -> IO (Maybe Template)
resolveTemplate namespace method = do
  paths <- templateSearchPaths
  let candidates =
        [ path </> T.unpack namespace </> T.unpack method <.> "hbs"
        | path <- paths
        ]
        ++ [ path </> "default.hbs" | path <- paths ]
  firstExisting candidates
```

## Module Design

### Types

```haskell
-- src/Plexus/Renderer.hs

module Plexus.Renderer
  ( -- * Types
    RendererConfig(..)
  , Template
  , RenderError(..)
    -- * Template Loading
  , loadTemplate
  , resolveTemplate
  , defaultSearchPaths
    -- * Rendering
  , render
  , renderJson
  , renderWithTemplate
    -- * Built-in Templates
  , defaultTemplate
  , jsonTemplate
  ) where

-- | Configuration for the renderer
data RendererConfig = RendererConfig
  { searchPaths    :: [FilePath]      -- ^ Template search paths
  , useColor       :: Bool            -- ^ Enable ANSI colors
  , defaultFormat  :: OutputFormat    -- ^ Fallback format
  }

data OutputFormat
  = FormatJson           -- ^ Raw JSON (current behavior)
  | FormatPrettyJson     -- ^ Pretty-printed JSON
  | FormatTemplate       -- ^ Use templates
  deriving (Show, Eq)

-- | Rendering errors
data RenderError
  = TemplateNotFound Text
  | TemplateParseError Text Text
  | RenderError Text
  deriving (Show, Eq)
```

### Core Functions

```haskell
-- | Render a response using the appropriate template
render :: RendererConfig
       -> Text              -- ^ Namespace (e.g., "arbor")
       -> Text              -- ^ Method (e.g., "tree_list")
       -> Value             -- ^ JSON response
       -> IO (Either RenderError Text)

-- | Load a template from disk
loadTemplate :: FilePath -> IO (Either RenderError Template)

-- | Resolve template path for a method
resolveTemplate :: RendererConfig
                -> Text              -- ^ Namespace
                -> Text              -- ^ Method
                -> IO (Maybe FilePath)
```

## Template Metadata (YAML Front Matter)

Templates use YAML front matter to specify which endpoint they handle:

```yaml
---
# Template for: synapse arbor tree-list
endpoint: arbor tree-list
description: List all conversation trees
schema_ref: arbor_tree_list  # Method name for schema lookup
---
{{#if trees}}
Trees ({{length trees}}):
...
```

### Metadata Fields

| Field | Required | Description |
|-------|----------|-------------|
| `endpoint` | Yes | CLI command path (e.g., `arbor tree-list`) |
| `description` | No | Human-readable description |
| `schema_ref` | No | Override schema lookup (defaults to endpoint) |
| `version` | No | Template version for caching |

### Schema Query

Get the JSON schema for any method:

```bash
# Dump schema for arbor tree-list
synapse --schema arbor tree-list

# Output:
{
  "description": "List all active trees",
  "properties": {
    "method": { "type": "string" },
    "params": { "type": "object" }
  },
  "required": ["method"]
}
```

This schema can be used to write templates - the Handlebars variables correspond to the schema properties.

## Template Examples

### `arbor/tree-list.hbs`

```handlebars
{{#if trees}}
Trees ({{length trees}}):
{{#each trees}}
  {{tree_id}}
    Owner: {{owner_id}}
    Refs:  {{ref_count}}
    Nodes: {{node_count}}
{{/each}}
{{else}}
No trees found.
{{/if}}
```

### `cone/registry.hbs`

```handlebars
Model Registry
==============

Services: {{stats.service_count}}
Models:   {{stats.model_count}}
Families: {{stats.family_count}}

{{#each families as |family|}}
• {{family}}
{{/each}}
```

### `default.hbs`

```handlebars
{{#if (isObject this)}}
{{json this pretty=true}}
{{else}}
{{this}}
{{/if}}
```

## Custom Helpers

```haskell
-- | Register custom Handlebars helpers
registerHelpers :: Handlebars -> IO ()
registerHelpers hbs = do
  -- JSON formatting
  registerHelper hbs "json" jsonHelper
  -- Length of arrays/objects
  registerHelper hbs "length" lengthHelper
  -- Conditional type checks
  registerHelper hbs "isObject" isObjectHelper
  registerHelper hbs "isArray" isArrayHelper
  -- Formatting
  registerHelper hbs "truncate" truncateHelper
  registerHelper hbs "date" dateHelper
  registerHelper hbs "uuid-short" uuidShortHelper
```

### Helper Examples

```handlebars
{{! Truncate long strings }}
{{truncate content 80}}

{{! Format UUIDs as short form }}
{{uuid-short tree_id}}  {{! abc123...def456 }}

{{! Format timestamps }}
{{date created_at "%Y-%m-%d %H:%M"}}

{{! Pretty print JSON subset }}
{{json metadata pretty=true indent=2}}
```

## CLI Integration

### Global Options Extension

```haskell
data GlobalOpts = GlobalOpts
  { optRefresh   :: Bool
  , optHost      :: String
  , optPort      :: Int
  , optJson      :: Bool        -- ^ Raw JSON (existing)
  , optTemplate  :: Maybe FilePath  -- ^ Override template
  , optFormat    :: OutputFormat    -- ^ Output format
  }
```

### Usage

```bash
# Use template rendering (default when templates exist)
synapse arbor tree-list

# Force raw JSON
synapse --json arbor tree-list

# Use specific template
synapse --template ./my-template.hbs arbor tree-list

# Pretty JSON (no template)
synapse --pretty arbor tree-list
```

## Implementation Plan

### Phase 1: Core Renderer Module

1. Create `src/Plexus/Renderer.hs` with types
2. Add `mustache` or `heist` dependency for Handlebars-like templating
3. Implement `loadTemplate` and `render`
4. Add `defaultSearchPaths`

### Phase 2: Template Resolution

1. Implement `resolveTemplate` with fallback chain
2. Add template caching (parse once, reuse)
3. Create default built-in templates

### Phase 3: CLI Integration

1. Add `--template` and `--format` flags
2. Modify `printResult` to use renderer
3. Add template discovery on startup

### Phase 4: Template Library

1. Create templates for arbor methods
2. Create templates for cone methods
3. Document template authoring

## Dependencies

```cabal
build-depends:
    ...
    mustache >= 2.4,         -- Handlebars-compatible templating
    -- OR
    heist >= 1.1,            -- More powerful templating
```

## File Structure

```
symbols/
├── src/
│   └── Plexus/
│       ├── Renderer.hs          -- Core renderer module
│       └── Renderer/
│           ├── Templates.hs     -- Built-in templates
│           └── Helpers.hs       -- Custom helpers
├── templates/                   -- Built-in templates (embedded)
│   ├── arbor/
│   │   ├── tree-list.hbs
│   │   └── tree-get.hbs
│   ├── cone/
│   │   └── registry.hbs
│   └── default.hbs
└── symbols.cabal
```
