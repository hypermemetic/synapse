# Schema-to-CLI Pipeline

**Date**: 2025-12-19
**Context**: Dynamic CLI generation from Plexus RPC schemas

## Overview

The synapse CLI is **dynamically generated** from schemas provided by the Plexus server. This document explains:
1. The common structure shared by all activation schemas
2. The meta-properties that enable CLI generation
3. The Haskell type hierarchy that models schemas
4. The complete pipeline from schema fetch to CLI execution

---

## Schema Structure: The Common Pattern

All Plexus activation schemas follow a **discriminated union** pattern using JSON Schema's `oneOf`:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "All available methods in the XYZ activation",
  "oneOf": [
    {
      "description": "Method description here",
      "properties": {
        "method": {
          "const": "method_name",    // ← DISCRIMINATOR TAG
          "type": "string"
        },
        "params": {                  // ← PAYLOAD SCHEMA
          "properties": {
            "param1": {
              "type": "string",
              "description": "..."
            },
            "param2": {
              "type": "integer",
              "format": "uuid"
            }
          },
          "required": ["param1"],    // ← REQUIRED SET
          "type": "object"
        }
      },
      "required": ["method", "params"],
      "type": "object"
    },
    // ... more method variants
  ]
}
```

### Meta-Properties

These are the **annotations** that enable CLI generation:

| Meta-Property | Location | Purpose | Example |
|---------------|----------|---------|---------|
| **Discriminator** | `properties.method.const` | Identifies which method variant this is | `"tree_create"` |
| **Payload Schema** | `properties.params.properties` | Defines parameter names and types | `{"tree_id": {type: "string", format: "uuid"}}` |
| **Required Set** | `properties.params.required` | Lists mandatory parameters | `["tree_id"]` |
| **Type** | `properties.params.properties.*.type` | JSON Schema type for parameter | `"string"`, `"integer"`, `["string", "null"]` |
| **Format Hint** | `properties.params.properties.*.format` | Semantic format | `"uuid"`, `"date-time"` |
| **Description** | `description` (at variant and param level) | Help text for CLI | `"UUID of the tree to retrieve"` |
| **Default** | `properties.params.properties.*.default` | Default value | `"system"`, `1` |

This is a **tagged union** pattern where:
- **Tag** = the method name (`method.const`)
- **Payload** = the parameters object (`params`)

---

## Type Hierarchy

### Layer 1: Discovery Schema (plexus_schema)

**Purpose**: Enumerate all activations and their methods

```haskell
-- Returned by plexus_schema RPC call
data PlexusSchema = PlexusSchema
  { schemaActivations  :: [ActivationInfo]
  , schemaTotalMethods :: Int
  }

data ActivationInfo = ActivationInfo
  { activationNamespace   :: Text         -- e.g., "arbor", "cone"
  , activationVersion     :: Text         -- e.g., "1.0.0"
  , activationDescription :: Text
  , activationMethods     :: [Text]       -- e.g., ["tree_create", "tree_get"]
  }
```

**CLI Mapping**: Creates the **activation subcommands** (arbor, cone, bash, etc.)

---

### Layer 2A: Parameter Schema (plexus_full_schema) - Current Approach

**Purpose**: Get typed parameter information for generating CLI flags

```haskell
-- Returned by plexus_full_schema RPC call
data ActivationFullSchema = ActivationFullSchema
  { fullSchemaNamespace   :: Text
  , fullSchemaVersion     :: Text
  , fullSchemaDescription :: Text
  , fullSchemaMethods     :: [MethodSchemaInfo]
  }

data MethodSchemaInfo = MethodSchemaInfo
  { methodInfoName        :: Text
  , methodInfoDescription :: Text
  , methodInfoParams      :: Maybe Value    -- ← Raw JSON Schema for params
  , methodInfoReturns     :: Maybe Value    -- ← Raw JSON Schema for returns
  }
```

**CLI Mapping**: For each method in `fullSchemaMethods`:
- Create a **method subcommand** (e.g., `arbor tree-create`)
- Parse `methodInfoParams` JSON Schema to extract parameters
- Generate typed flags from parameter properties

---

### Layer 2B: Method Enum Schema (plexus_activation_schema) - Legacy

**Purpose**: Get full JSON Schema with oneOf variants

```haskell
-- Returned by plexus_activation_schema RPC call
data EnrichedSchema = EnrichedSchema
  { schemaTitle       :: Maybe Text
  , schemaDescription :: Maybe Text
  , schemaType        :: Maybe Value
  , schemaProperties  :: Maybe (Map Text SchemaProperty)
  , schemaRequired    :: Maybe [Text]
  , schemaOneOf       :: Maybe [EnrichedSchema]    -- ← Method variants
  , schemaDefs        :: Maybe (Map Text Value)    -- ← For $ref resolution
  , schemaRef         :: Maybe Text                -- ← Reference (e.g., "#/$defs/...")
  }

data SchemaProperty = SchemaProperty
  { propType        :: Maybe Value              -- "string", ["string", "null"]
  , propDescription :: Maybe Text
  , propFormat      :: Maybe Text               -- "uuid", "date-time"
  , propItems       :: Maybe SchemaProperty     -- For arrays
  , propDefault     :: Maybe Value
  , propEnum        :: Maybe [Value]
  , propProperties  :: Maybe (Map Text SchemaProperty)
  , propOneOf       :: Maybe [SchemaProperty]   -- Nested discriminated unions
  , propRef         :: Maybe Text               -- "#/$defs/ConeIdentifier"
  }
```

**CLI Mapping**:
- `schemaOneOf` contains method variants
- Each variant is parsed into a `MethodSchema`
- Supports `$ref` resolution for complex types (e.g., cone's `ConeIdentifier`)

---

### Layer 3: Parsed Schema (Internal Representation)

**Purpose**: Normalized form optimized for CLI generation

```haskell
data MethodSchema = MethodSchema
  { methodName        :: Text
  , methodDescription :: Maybe Text
  , methodParams      :: [ParamSchema]
  }

data ParamSchema = ParamSchema
  { paramName     :: Text
  , paramType     :: ParamType
  , paramFormat   :: Maybe Text
  , paramRequired :: Bool
  , paramDesc     :: Maybe Text
  , paramDefault  :: Maybe Value
  }

data ParamType
  = ParamString
  | ParamInteger
  | ParamNumber
  | ParamBoolean
  | ParamObject
  | ParamArray ParamType
  | ParamNullable ParamType
```

**CLI Mapping**: Direct 1:1 mapping to optparse-applicative parsers

---

## The Pipeline: Schema → CLI → RPC

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. DISCOVERY PHASE                                                  │
│    Fetch available activations and methods                          │
└─────────────────────────────────────────────────────────────────────┘
          │
          │ RPC: plexus_schema → PlexusSchema
          ↓
    ┌──────────────┐
    │ PlexusSchema │  activations: [ActivationInfo]
    │              │  - arbor: [tree_create, tree_get, ...]
    │              │  - cone: [create, chat, get, ...]
    │              │  - bash: [execute]
    └──────────────┘
          │
          │ Cache with hash-based invalidation
          ↓

┌─────────────────────────────────────────────────────────────────────┐
│ 2. ENRICHMENT PHASE                                                 │
│    Fetch parameter schemas for each activation                      │
└─────────────────────────────────────────────────────────────────────┘
          │
          │ For each activation namespace:
          │   RPC: plexus_full_schema(namespace) → ActivationFullSchema
          ↓
    ┌────────────────────────┐
    │ ActivationFullSchema   │  methods: [MethodSchemaInfo]
    │                        │  - name: "tree_create"
    │                        │    params: {
    │                        │      properties: {
    │                        │        tree_id: {type: "string", format: "uuid"}
    │                        │      },
    │                        │      required: ["tree_id"]
    │                        │    }
    └────────────────────────┘
          │
          │ Cache alongside PlexusSchema
          ↓

┌─────────────────────────────────────────────────────────────────────┐
│ 3. PARSING PHASE                                                    │
│    Extract method and parameter metadata                            │
└─────────────────────────────────────────────────────────────────────┘
          │
          │ extractSchemaInfo :: Value → (Map Text Value, [Text])
          │   - Extract properties from params JSON Schema
          │   - Extract required list
          ↓
    ┌──────────────┐         ┌──────────────────┐
    │ Properties   │         │ Required         │
    │ Map          │         │ [Text]           │
    │              │         │                  │
    │ tree_id →    │         │ ["tree_id"]      │
    │   {type:...} │         │                  │
    └──────────────┘         └──────────────────┘
          │                          │
          └──────────┬───────────────┘
                     ↓
          buildParamParserFromSchema :: (Text, Value) → Parser (Text, Maybe Value)
                     │
                     │ For each parameter:
                     │   - Extract type, format, description
                     │   - Determine if required
                     │   - Build optparse-applicative parser
                     ↓

┌─────────────────────────────────────────────────────────────────────┐
│ 4. CLI GENERATION PHASE                                             │
│    Build hierarchical command parsers                               │
└─────────────────────────────────────────────────────────────────────┘
          │
          │ buildDynamicParserWithSchemas :: PlexusSchema
          │                               → Map Text ActivationFullSchema
          │                               → Parser CommandInvocation
          ↓
    Hierarchy:
      synapse
        │
        ├─ arbor                    ← From PlexusSchema.activationNamespace
        │    ├─ tree-create         ← From ActivationFullSchema.methods[].name
        │    │    ├─ --tree-id      ← From methodInfoParams.properties.tree_id
        │    │    └─ --metadata
        │    └─ tree-get
        │         └─ --tree-id
        │
        ├─ cone
        │    ├─ create
        │    │    ├─ --name         ← Required parameter (sorted first)
        │    │    ├─ --model-id     ← Required parameter
        │    │    └─ --system-prompt ← Optional parameter (sorted after)
        │    └─ chat
        │         ├─ --identifier
        │         └─ --prompt
        │
        └─ bash
             └─ execute
                  └─ --command

    Type Mapping:
      JSON Schema type     → optparse-applicative parser
      ───────────────────────────────────────────────────────
      "string"             → strOption :: Parser String
      "integer"            → option auto :: Parser Int
      "number"             → option auto :: Parser Double
      "boolean"            → switch (flag, no value needed)
      ["string", "null"]   → optional (strOption)

    Metavar Mapping:
      format: "uuid"       → metavar "UUID"
      type: "string"       → metavar "TEXT"
      type: "integer"      → metavar "INT"
      type: "number"       → metavar "NUM"

    Help Text:
      param description    → help "..."
      method description   → progDesc "..."

          │
          ↓
    ┌────────────────────┐
    │ Parser             │  Parser CommandInvocation
    │ CommandInvocation  │    { invMethod :: Text
    │                    │    , invParams :: Value
    │                    │    }
    └────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│ 5. EXECUTION PHASE                                                  │
│    Parse CLI args and execute RPC call                              │
└─────────────────────────────────────────────────────────────────────┘
          │
          │ execParser :: Parser CommandInvocation → IO CommandInvocation
          │
          ↓
    User input:  synapse arbor tree-create --tree-id abc-123
          │
          ↓
    CommandInvocation
      { invMethod = "arbor_tree_create"
      , invParams = Object [("tree_id", String "abc-123")]
      }
          │
          │ plexusRpc :: PlexusConnection → Text → Value → Stream PlexusStreamItem IO ()
          ↓
    RPC Request:
      { "jsonrpc": "2.0"
      , "id": 1
      , "method": "arbor_tree_create"
      , "params": {"tree_id": "abc-123"}
      }
          │
          ↓
    WebSocket → Plexus Server
          │
          ↓
    Stream Results:
      StreamData {...}     → Print formatted output
      StreamError {...}    → Check if param error → show help
      StreamDone           → Exit
```

---

## Key Design Decisions

### 1. **Two Schema Endpoints**

- **plexus_schema**: Lightweight, lists all methods (used for activation-level CLI)
- **plexus_full_schema**: Rich, includes param/return schemas (used for typed flags)

**Rationale**: Separation allows fast CLI skeleton generation without fetching full schemas unless needed.

### 2. **Cache Full Schemas**

Both `PlexusSchema` and all `ActivationFullSchema` are cached together:

```haskell
data CachedSchema = CachedSchema
  { cachedHash        :: Text
  , cachedSchema      :: PlexusSchema
  , cachedFullSchemas :: Map Text ActivationFullSchema
  }
```

**Rationale**: Avoid multiple RPC calls on every CLI invocation. Hash-based invalidation ensures cache freshness.

### 3. **Sort Parameters: Required First**

```haskell
let sortedParams = sortOn (\(name, _) -> name `notElem` required) (Map.toList properties)
```

**Rationale**: Better UX - users see required params at the top of help output.

### 4. **Allow JSON Override**

Every typed method parser includes a hidden `--params JSON` flag:

```haskell
mJsonOverride <- optional $ strOption
  ( long "params" <> short 'p' <> metavar "JSON"
 <> help "Override with raw JSON object" <> hidden )
```

**Rationale**: Power users can bypass typed flags for complex/nested objects.

### 5. **Index-Based Method Lookup**

The `EnrichedSchema` oneOf array order matches the method order in `ActivationInfo.methods`:

```haskell
parseMethodVariantByIndex :: EnrichedSchema -> Int -> Maybe MethodSchema
```

**Rationale**: Some schemas don't include method names in the oneOf variants (just a `const` discriminator). Index-based lookup provides a fallback.

### 6. **Error Help Display**

When an RPC call fails with a parameter error, show the actual help output:

```haskell
isParamError :: Text -> Bool
isParamError err =
  T.isInfixOf "-32602" err ||
  T.isInfixOf "Invalid params" err ||
  T.isInfixOf "missing required" err
```

**Rationale**: Better DX - users immediately see what parameters are available rather than re-running with `--help`.

---

## Type System Correspondence

| JSON Schema Type | Haskell ParamType | optparse-applicative Parser | CLI Metavar |
|------------------|-------------------|-----------------------------|-------------|
| `"string"` | `ParamString` | `strOption :: Parser String` | `TEXT` |
| `"integer"` | `ParamInteger` | `option auto :: Parser Int` | `INT` |
| `"number"` | `ParamNumber` | `option auto :: Parser Double` | `NUM` |
| `"boolean"` | `ParamBoolean` | `switch` (flag, no value) | (none) |
| `"object"` | `ParamObject` | `strOption` (JSON string) | `JSON` |
| `"array"` | `ParamArray t` | `strOption` (JSON string) | `JSON` |
| `["string", "null"]` | `ParamNullable ParamString` | `optional (strOption)` | `TEXT` |
| format: `"uuid"` | `ParamString` with format | `strOption` | `UUID` |

---

## Future Enhancements

### 1. **Positional Arguments**

For single-parameter methods (like `bash execute`), support:
```bash
synapse bash execute "echo hello"  # Instead of --command "echo hello"
```

### 2. **Complex Type Support**

Currently, complex types (objects, arrays) fall back to JSON strings. Could generate nested flags:
```bash
# Instead of: --identifier '{"by_name": {"name": "assistant"}}'
# Support: --identifier-by-name assistant
```

### 3. **Validation**

Validate parameter values against JSON Schema constraints:
- `minLength`, `maxLength` for strings
- `minimum`, `maximum` for numbers
- `enum` for restricted values

### 4. **Shell Completion**

Generate bash/zsh completion scripts from schemas:
- Complete activation names
- Complete method names
- Complete parameter names
- Complete enum values

---

## Summary

The schema-to-CLI pipeline is a **multi-layer transformation**:

1. **Discovery**: JSON-RPC (`plexus_schema`) → Haskell (`PlexusSchema`)
2. **Enrichment**: JSON-RPC (`plexus_full_schema`) → Haskell (`ActivationFullSchema`)
3. **Parsing**: JSON Schema (`methodInfoParams`) → Parameter metadata
4. **Generation**: Parameter metadata → optparse-applicative (`Parser CommandInvocation`)
5. **Execution**: CLI args → RPC call → Stream results

The **meta-properties** that enable this are:
- **Discriminator** (`method.const`): Method name
- **Payload Schema** (`params.properties`): Parameter definitions
- **Required Set** (`params.required`): Mandatory parameters
- **Types and Formats**: Map to CLI parsers and help text

This architecture allows the CLI to **dynamically adapt** to backend changes without recompilation—new methods, parameters, or entire activations appear automatically once the server's schema updates.
